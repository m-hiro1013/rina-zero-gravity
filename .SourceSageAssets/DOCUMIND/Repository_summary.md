# Project: ZERO_GRAVITY

```plaintext
OS: posix
Directory: /mnt/d/Prj/ZERO_GRAVITY

├── .agent/
│   ├── rules/
│   │   ├── character-rules-seira.md
│   │   ├── code-review.md
│   │   ├── documentation.md
│   │   ├── ga-workspace-definition.md
│   │   ├── git-workflow.md
│   │   ├── japanese-rules.md
│   │   ├── meta-rule-creation.md
│   │   ├── meta-workflow-creation.md
│   │   ├── ops.md
│   │   ├── project-governance.md
│   │   ├── react-components.md
│   │   ├── rule-templates.md
│   │   ├── security-mandates.md
│   │   ├── stack.md
│   │   ├── testing-standards.md
│   │   ├── type-safety.md
│   │   └── workflow-templates.md
│   └── workflows/
│       ├── auto-generate-agent-config.md
│       ├── bug-fix.md
│       ├── code-review.md
│       ├── create-feature.md
│       ├── create-rule.md
│       ├── create-workflow.md
│       ├── deploy-staging.md
│       ├── generate-readme.md
│       ├── generate-unit-tests.md
│       ├── health-check.md
│       ├── lint-check.md
│       ├── manage-agent-config.md
│       ├── performance-optimization.md
│       ├── run-tests.md
│       ├── security-scan.md
│       ├── setup-ga-workspace.md
│       ├── type-check.md
│       ├── ui-verification.md
│       └── verify-code.md
└── ANTIGRAVITY_AGENT_CONTROL_SPEC.MD
```

## 📂 Gitリポジトリ情報

### 🌐 基本情報

- 🔗 リモートURL: https://github.com/Sunwood-ai-labs/ZERO_GRAVITY.git
- 🌿 デフォルトブランチ: main
- 🎯 現在のブランチ: main
- 📅 作成日時: 2025-12-30 16:18:31
- 📈 総コミット数: 1

### 🔄 最新のコミット

- 📝 メッセージ: Initial commit for ZERO_GRAVITY
- 🔍 ハッシュ: 34593369
- 👤 作者: Sunwood-ai-labs (Sunwood-ai-labs@users.noreply.github.com)
- ⏰ 日時: 2025-12-30 16:23:28

### 👥 主要コントリビューター

| 👤 名前 | 📊 コミット数 |
|---------|-------------|
| Sunwood-ai-labs | 1 |

## 📊 プロジェクト統計

- 📅 作成日時: 2025-12-30 18:05:35
- 📁 総ディレクトリ数: 3
- 📄 総ファイル数: 37
- 📏 最大深度: 2
- 📦 最大ディレクトリ:  (40 エントリ)

### 📊 ファイルサイズと行数

| ファイル | サイズ | 行数 | 言語 |
|----------|--------|------|------|
| ANTIGRAVITY_AGENT_CONTROL_SPEC.MD | 32.0 KB | 361 | markdown |
| .agent/rules/meta-workflow-creation.md | 8.7 KB | 277 | markdown |
| .agent/rules/workflow-templates.md | 5.9 KB | 249 | markdown |
| .agent/rules/rule-templates.md | 4.7 KB | 182 | markdown |
| .agent/workflows/auto-generate-agent-config.md | 5.5 KB | 168 | markdown |
| .agent/rules/ga-workspace-definition.md | 5.4 KB | 131 | markdown |
| .agent/workflows/create-workflow.md | 4.5 KB | 126 | markdown |
| .agent/rules/project-governance.md | 4.9 KB | 125 | markdown |
| .agent/workflows/health-check.md | 3.3 KB | 122 | markdown |
| .agent/workflows/ui-verification.md | 3.7 KB | 114 | markdown |
| .agent/workflows/setup-ga-workspace.md | 3.6 KB | 111 | markdown |
| .agent/rules/react-components.md | 2.7 KB | 108 | markdown |
| .agent/rules/meta-rule-creation.md | 3.7 KB | 101 | markdown |
| .agent/workflows/create-rule.md | 3.3 KB | 98 | markdown |
| .agent/rules/ops.md | 1.4 KB | 91 | markdown |
| .agent/rules/type-safety.md | 2.2 KB | 84 | markdown |
| .agent/rules/character-rules-seira.md | 2.9 KB | 80 | markdown |
| .agent/workflows/manage-agent-config.md | 2.7 KB | 79 | markdown |
| .agent/workflows/bug-fix.md | 2.3 KB | 74 | markdown |
| .agent/workflows/create-feature.md | 2.3 KB | 71 | markdown |
| .agent/workflows/deploy-staging.md | 2.0 KB | 68 | markdown |
| .agent/workflows/performance-optimization.md | 1.8 KB | 62 | markdown |
| .agent/workflows/code-review.md | 1.9 KB | 61 | markdown |
| .agent/workflows/generate-readme.md | 1.6 KB | 59 | markdown |
| .agent/workflows/verify-code.md | 1.7 KB | 56 | markdown |
| .agent/rules/security-mandates.md | 1.6 KB | 50 | markdown |
| .agent/rules/stack.md | 959.0 B | 42 | markdown |
| .agent/workflows/generate-unit-tests.md | 1.6 KB | 38 | markdown |
| .agent/rules/git-workflow.md | 1.1 KB | 32 | markdown |
| .agent/rules/japanese-rules.md | 907.0 B | 32 | markdown |
| .agent/workflows/security-scan.md | 1.0 KB | 31 | markdown |
| .agent/rules/documentation.md | 1.1 KB | 28 | markdown |
| .agent/rules/testing-standards.md | 1010.0 B | 27 | markdown |
| .agent/rules/code-review.md | 1.0 KB | 26 | markdown |
| .agent/workflows/run-tests.md | 613.0 B | 22 | markdown |
| .agent/workflows/lint-check.md | 646.0 B | 21 | markdown |
| .agent/workflows/type-check.md | 549.0 B | 20 | markdown |
| **合計** |  | **3427** |  |

### 📈 言語別統計

| 言語 | ファイル数 | 総行数 | 合計サイズ |
|------|------------|--------|------------|
| markdown | 37 | 3427 | 126.7 KB |

`ANTIGRAVITY_AGENT_CONTROL_SPEC.MD`

**サイズ**: 32.0 KB | **行数**: 361 行
```markdown
# Google Antigravityにおける高度なエージェント制御：RulesとWorkflowsの技術仕様および相互作用に関する包括的分析

## 1. エグゼクティブサマリー

2025年11月、Google Antigravityの登場は、ソフトウェア開発エコシステムにおける「AI支援（AI Assistance）」から「エージェント主導開発（Agentic Development Environment - ADE）」へのパラダイムシフトを決定づける転換点となった。従来の統合開発環境（IDE）がコード補完やチャットボットによる局所的な支援に留まっていたのに対し、AntigravityはGemini 3 ProやGemini 3 Deep Thinkといったフロンティアモデルを搭載した自律型エージェントをオーケストレーションするためのプラットフォームとして再定義されている。

本レポートは、Antigravityにおけるエージェント制御の中核を成す二つの機構、「Rules（ルール）」と「Workflows（ワークフロー）」について、その技術仕様、定義構文、およびランタイムにおける相互作用メカニズムを徹底的に解明することを目的とする。

調査の結果、Rulesはエージェントの「憲法」として機能し、永続的なコンテキスト境界と行動制約（何をすべきか、何をすべきでないか）を宣言的に定義するものであることが明らかになった。対してWorkflowsは、エージェントの「標準作業手順書（SOP）」として機能し、特定のタスクを達成するための軌道と操作ロジック（どのように動くか）を命令的に記述するものである。

これら二つの機能は独立して存在するのではなく、エージェントマネージャー（Mission Control）によって動的に統合され、高度に決定論的かつ柔軟なタスク実行を実現している。特に、Antigravityの「Model Decision（モデルによる決定）」トリガーや、ワークフロー内の「Turbo Mode（ターボモード）」といった機能は、従来のAIコーディングツールが抱えていたコンテキストの過負荷や実行速度のボトルネックを解消するための重要な技術的進歩である。

本稿では、これらの機能を活用し、開発者が単なるコーダーから、自律エージェント群を指揮するシステムアーキテクトへと役割を進化させるためのベストプラクティスを、具体的なコード例と運用フロー図を交えて提示する。

## 2. Antigravityにおけるエージェントアーキテクチャの基本概念

RulesとWorkflowsの詳細な技術仕様に踏み込む前に、それらが動作するAntigravityの基盤アーキテクチャを理解する必要がある。AntigravityはVisual Studio Codeのフォークとして構築されているが、そのメンタルモデルは根本的に異なっている。

### 2.1 コパイロットから「同僚」への進化

従来のGitHub Copilotや初期のCursorは、開発者の入力に対する「予測と補完」のループで動作していた。これに対しAntigravityは、「タスクの委任と監視」のループを採用している。開発者はコードを書くのではなく、Agent Manager（エージェントマネージャー）と呼ばれる専用のインターフェースを通じてタスク（例：「認証モジュールのリファクタリング」）を発行する。

このアーキテクチャにおいて、エージェントは以下の3つのサーフェス（操作面）を横断して自律的に活動する：

*   **Code Editor（エディタ）**: ソースコードの読み取り、書き込み、ファイル操作を行う。Gemini 3 Proの100万トークンを超えるコンテキストウィンドウにより、リポジトリ全体をメモリに保持したかのような推論が可能となる。
*   **Terminal（ターミナル）**: ビルドコマンド、テスト実行、Git操作、システムスクリプトの実行を行う。エージェントはエラー出力を解析し、自律的に修正を試みる「自己修復ループ」を持つ。
*   **Browser Subagent（ブラウザサブエージェント）**: ヘッドレス（または可視化された）Chromeインスタンスを操作し、WebアプリケーションのDOM操作、スクリーンショット撮影、セッション記録を行う。これにより、従来の単体テストでは捕捉できないUIの崩れや動的な挙動の検証が可能となる。

### 2.2 制御構造の必要性：決定論と自律性のバランス

エージェントの自律性が高まることは、同時に予測不可能性のリスクを増大させる。特にGemini 3 Deep Thinkのような推論能力の高いモデルは、指示が曖昧な場合、独創的すぎる解決策や、プロジェクトの既存規約を無視したコードを生成する可能性がある（いわゆる「幻覚」や「逸脱」）。

ここで「Rules」と「Workflows」が不可欠な制御機構として機能する。これらはLLMという「原子炉」に対する「制御棒」の役割を果たし、エージェントの出力をプロジェクトの要件に適合させるためのガードレールを提供する。

*   **Rules (宣言的制御)**: コンテキストに永続的に注入され、エージェントの判断基準を規定する。「常にType Hintsを使用せよ」「any型は禁止する」といった静的な制約。
*   **Workflows (手続き的制御)**: タスクの実行手順を規定する。「ファイルを解析し、テスト計画を立て、実装し、検証する」という一連のフロー。

次章以降で、これらの技術仕様を詳細に分解していく。

## 3. 技術詳解：Rules（ルール）機能の仕様と挙動

Google AntigravityのRulesエンジンは、単なるシステムプロンプトの拡張ではなく、大規模なコードベースに対応するための動的でコンテキスト指向の制約管理システムである。

### 3.1 定義とストレージ構造

Rulesは、ワークスペースのルートディレクトリにある `.agent/rules/` フォルダ内に格納される。従来の `.cursorrules` が単一ファイル（または少数のファイル）に依存しがちであったのに対し、Antigravityは分散型ルールアーキテクチャを推奨している。

**ディレクトリ構造のベストプラクティス**

Antigravityのプロジェクトでは、以下のような階層的なルール定義が一般的である：

```text
my-project/
├── .agent/
│   ├── rules/
│   │   ├── 00-core-architecture.md   # プロジェクト全体の基本方針
│   │   ├── 10-python-style.md        # 言語固有のスタイルガイド
│   │   ├── 20-security-policy.md     # セキュリティ要件
│   │   └── frontend/                 # フロントエンド固有のルール
│   │       ├── react-components.md
│   │       └── tailwind-usage.md
└── src/
```

この構造により、ルールの可読性と保守性が向上する。また、グローバルレベル（ユーザーのホームディレクトリ、例：`~/.gemini/GEMINI.md`）でのルール定義もサポートされており、個人の好みを反映させることも可能である。

優先順位は通常、グローバル < ワークスペース < フォルダ固有 の順で適用されるが、後述するトリガーメカニズムによって動的に制御される。

### 3.2 構文とスキーマ：YAML Frontmatterの役割

Ruleファイルの実体はMarkdownファイルであるが、その挙動を制御するのはファイル先頭の YAML Frontmatter である。ここで、そのルールが「いつ」「どのように」エージェントのコンテキストに注入されるかを定義する。

**基本構文例** (`.agent/rules/type-safety.md`)

```markdown
---
slug: type-safety
description: Pythonコードにおける型ヒントとPydanticの使用に関する厳格な基準を強制する。
trigger: always_on
---
# Type Safety Standards

このプロジェクトで生成または修正されるすべてのPythonコードは、以下の基準を満たす必要がある：

1. **完全な型アノテーション**: すべての関数シグネチャ（引数および戻り値）に型ヒントを付与すること。
2. **Anyの禁止**: `typing.Any` の使用は原則禁止とする。外部ライブラリの制約などで不可避な場合は、コメントで理由を明記すること。
3. **Pydantic V2**: データ転送オブジェクト（DTO）の定義には必ず Pydantic V2 を使用し、ConfigDict で `strict=True` を設定すること。
```

### 3.3 トリガーメカニズム：コンテキストウィンドウの最適化

Antigravityの最大の技術的特長の一つが、高度なトリガーシステムである。巨大なモノレポにおいて、すべてのルールを常にコンテキストに含めることは、トークンコストの浪費であり、モデルの注意力を散漫にさせる原因となる。Antigravityは4つのトリガータイプによってこれを解決している。

以下の表は、各トリガータイプの技術的特性をまとめたものである。

| トリガータイプ | 定義構文 (`trigger:`) | 動作メカニズム | 推奨ユースケース |
| :--- | :--- | :--- | :--- |
| **Always On** | `always_on` | エージェントの初期化時にシステムプロンプトの一部として無条件に注入される。 | プロジェクト全体のアーキテクチャ原則、禁止事項、コーディングスタイルの基礎。 |
| **Manual** | `manual` | ユーザーがチャット内で `@rule-name` の形式で明示的にメンションした場合のみロードされる。 | 頻度の低い特定のタスク（例：DBマイグレーション、大規模リファクタリング、監査）。 |
| **Glob Pattern** | glob | 編集中のファイルパスや、タスクに関連するファイル群が指定されたGlobパターン（例：`**/*.tsx`）にマッチした場合に自動的にロードされる。 | 言語固有のルール（React、SQL、Python）、特定のディレクトリ配下のモジュールルール。 |
| **Model Decision** | `model_decision` | ユーザーのプロンプト（意図）を解析し、ルール定義内の `description` との意味的類似性が高い場合に、エージェントが自律的にロードを決定する。 | 「パフォーマンス改善」「セキュリティチェック」など、ファイルパスだけでは判定できない抽象的なタスク。 |

#### 3.3.1 Model Decision（モデルによる決定）の深層

`model_decision` は最も先進的な機能である。内部的には、Agent Managerが軽量なルーティングモデル（またはEmbeddingモデル）を使用していると推測される。ユーザーが「このコードのパフォーマンスを上げて」と入力すると、システムは登録された `model_decision` ルールの description フィールドをスキャンし、意図が合致するルール（例：「計算量削減のガイドライン」）を動的にプルしてくる。これにより、ユーザーはルールの存在を知らなくとも、適切なガバナンスを受けることができる「ゼロショット設定（Zero-Shot Configuration）」が可能となる。

### 3.4 内部検証プロセスと継承構造

エージェントが起動すると、以下のプロセスでコンテキストが構築される：

1.  **インデックスフェーズ**: `.agent/rules` ディレクトリをスキャンし、YAMLメタデータをパースして「ルールインデックス」をメモリ上に構築する。
2.  **フィルタリングフェーズ**: 現在のアクティブなファイルセットとユーザーのプロンプトに基づき、適用すべきルールを選別する。
3.  **コンテキスト注入**: 選別されたルールのMarkdown本文が、エージェントへのシステムメッセージ（System Instruction）に追加される。
4.  **優先順位の解決**: 競合するルール（例：グローバル設定で「タブ使用」、ローカル設定で「スペース使用」）が存在する場合、一般的には 「より具体的なスコープ」 を持つルールが優先される（ディレクトリ固有 > ワークスペース全体 > グローバル）。

### 3.5 リファレンス機能によるモジュール化

Markdownの標準機能に加え、Antigravityのルールでは `@` 記法を用いたファイル参照が可能である。`@path/to/another-rule.md` と記述することで、他のルールファイルの内容をインライン展開できる。これにより、「バックエンド開発基準」というマスタールールの中に、「API設計規則」「DB命名規則」「エラーハンドリング」といった細かいルールを包含させることができ、ルールの重複管理を防ぐことができる。

## 4. 技術詳解：Workflow（ワークフロー）による自律的タスク分解

Rulesが「静的」な制約であるのに対し、Workflowsは「動的」な手順書である。AntigravityにおけるWorkflowは、エージェントに対する **実行可能な標準作業手順書（Executable SOP）** であり、IDEを単なるエディタからタスク自動化プラットフォームへと昇華させる。

### 4.1 定義とファイル構造

Workflowsは `.agent/workflows/` ディレクトリにMarkdownファイルとして保存される。これらはAgent Managerのコマンドパレット（/ コマンド）から呼び出すことができる。

**ファイル命名規則と呼び出し**

ファイル名がそのままコマンド名となる。例えば `.agent/workflows/deploy-staging.md` は、チャット欄で `/deploy-staging` と入力することで起動する。

### 4.2 Workflow構文：プロンプトスクリプティング言語

Workflowファイルは、YAMLフロントマターと、自然言語によるステップ定義で構成される。Gemini 3 Proの高度な理解力により、厳密なプログラミング言語ではなく、構造化された自然言語で記述できる点が特徴である。

**標準的なWorkflow定義例** (`.agent/workflows/generate-unit-tests.md`)

```markdown
---
description: 現在アクティブなファイルに対して、Pytestを使用した単体テストを生成し、実行・修正までを行う。
---
# Unit Test Generation Workflow

## Step 1: Analyze Context
現在開いているファイルを読み込み、すべてのパブリック関数とクラスを特定せよ。
各関数の複雑度（Cyclomatic Complexity）と、想定されるエッジケース（境界値、Null入力、例外）を分析せよ。

## Step 2: Create Test Plan
分析結果に基づき、テストケースのリストを箇条書きで作成し、ユーザーに提示せよ。
制約: データベース接続を伴う処理は、unittest.mock を用いてモック化すること。

## Step 3: Generate Code
tests/ ディレクトリ配下に test_{filename}.py を作成し、Pytest形式でテストコードを実装せよ。
Rulesで定義されたコーディング規約（型ヒント、docstring）を遵守すること。

## Step 4: Verification // turbo
ターミナルで pytest tests/test_{filename}.py を実行せよ。
テストが失敗した場合、エラーログを分析し、テストコードまたは実装コードを修正して再実行せよ。この修正サイクルは最大3回まで繰り返すこと。
```

### 4.3 Manager Viewにおけるタスク分解と可視化

Workflowが実行されると、Agent Manager（Mission Control）は記述されたステップを解析し、個別の Task Nodes（タスクノード） に分解する。

*   **可視化（Visualization）**: Manager Viewには、現在実行中のステップ、完了したステップ、待機中のステップがチェックリストや依存関係グラフとして表示される。
*   **状態管理（State Management）**: エージェントは各ステップの状態（Pending, In Progress, Completed, Failed）を追跡する。
*   **並列実行（Parallelism）**: Workflow内に独立したタスク（例：「iOSアプリの修正」と「Androidアプリの修正」）が含まれる場合、Agent Managerは複数のサブエージェント（Sub-Agents）を起動し、並列に処理を進めることができる。メインのエージェントは「オーケストレーター」としてこれらを監督する。

### 4.4 高度な機能とツール連携

#### 4.4.1 再帰的合成（Recursive Composition）
Workflowは他のWorkflowを呼び出すことができる。例えば `/release-feature` というマスターワークフローが、内部で `/lint-check`, `/generate-docs`, `/deploy` を順次呼び出す構造が可能である。これにより、組織は「エージェント・スキル」のライブラリを構築し、再利用性を高めることができる。

#### 4.4.2 外部ツール連携とTurbo Mode
Workflow内では、エージェントが持つツール機能を明示的に呼び出すことができる。

*   `run_command`: シェルコマンドを実行する。ビルド、テスト、Lint、Git操作などに使用。
*   **Turbo Annotation (`// turbo`)**: ステップ定義に `// turbo` または `// turbo-all` という注釈を加えることで、エージェントはユーザーの承認を待たずにコマンドを実行する権限を得る（ただし、Deny Listにある危険なコマンドを除く）。これにより、完全自律型の「Human-out-of-the-loop」な処理が可能になる。
*   `browser_action`: Browser Subagentに対し、「指定URLへ遷移」「ボタンのクリック」「要素の検証」を指示する。これはAntigravity独自の強力な機能であり、E2Eテストの自動生成と実行を可能にする。

#### 4.4.3 論理制御構造（ループと分岐）
Workflowの記述はMarkdownだが、実行エンジンであるGeminiモデルは論理構造を解釈する。

*   **ループ**: 「テストが通るまで最大3回繰り返す」「すべてのファイルに対して実行する」といった指示は、エージェントによって制御ループとして実行される。
*   **条件分岐**: 「ビルドが失敗した場合は `/rollback` を実行し、成功した場合はSlackに通知する」といった条件分岐も、エージェントが実行結果（終了コードや出力）を評価して動的にパスを選択する。

## 5. 相乗効果：RulesとWorkflowsの相互作用メカニズム

Google Antigravityの真価は、RulesとWorkflowsが交差する点にある。これらは独立して動作するのではなく、重層的な制御システムを構成する。

### 5.1 相互作用のモデル：動的コンテキスト合成

開発者がWorkflow（例：`/refactor-auth`）を起動した際、Agent Managerは以下のような計算式で **複合コンテキスト（Composite Context）** を構築するイメージとなる：

$$C_{total} = C_{system} + C_{rules} + C_{workflow} + C_{history}$$

1.  **ルールの選定（Selection）**: まず、現在有効なRulesが特定される。`always_on` のルールがロードされる。Workflowのdescriptionや内容（「リファクタリング」）に基づき、`model_decision` トリガーを持つ関連ルール（例：`refactoring-guidelines.md`）がアクティブ化される。Workflowが触れるファイルに基づき、`glob` トリガーのルールがロードされる。
2.  **制約の適用（Application）**: エージェントは、Rulesという「レンズ」を通してWorkflowの各ステップを実行する。
    *   **Workflowの指示**: 「ユーザー作成クラスを新規作成せよ。」
    *   **Rulesの制約**: 「すべてのクラスはイミュータブルなデータクラスでなければならない。」
    *   **結果**: エージェントは、Workflowには明記されていなくても、Rulesに従って `@dataclass(frozen=True)` を付与したクラスを生成する。

### 5.2 競合解決と優先順位

検証ログやコミュニティの報告によると、一般的な優先順位は以下の通りである：

`ユーザーの直接指示 (最高) > Workflow内の指示 > ワークスペースRules > グローバルRules (最低)`

ただし、Rulesに「禁止事項（Negative Constraints）」として強く記述された内容（例：「`eval()`は絶対に使用してはならない」）は、Geminiモデルの安全性トレーニングとも相まって、Workflow内の曖昧な指示よりも優先される傾向がある。

### 5.3 ケーススタディ：「リファクタリング」の標準設定サンプル

この相互作用を具体的に示すため、リファクタリングタスクにおける設定例を示す。

**Rule: `.agent/rules/refactoring.md`**

```yaml
---
trigger: model_decision
description: ユーザーがコードのリファクタリング、技術的負債の解消、またはコード整理を求めた場合に適用する。
---
# Refactoring Constraints

1. **振る舞いの保存**: 変更の前後で既存のテストが通過することを最優先とする。
2. **Atomic Commits**: 論理的な変更単位ごとに小さくコミットを作成すること。コミットメッセージは Conventional Commits に従う。
3. **ドキュメントの更新**: 関数シグネチャを変更した場合は、必ず docstring を更新すること。
```

**Workflow: `.agent/workflows/clean-module.md`**

```markdown
---
description: 指定されたレガシーモジュールを体系的にクリーンアップする。
---
# Module Cleanup Workflow

## Analyze
未使用のインポート、到達不能コード（Dead Code）、非推奨の関数呼び出しを特定せよ。

## Refactor
複雑な条件分岐をガード節（Guard Clauses）を用いて簡素化せよ。

## Verify // turbo
プロジェクトのテストスイートを実行し、リグレッションがないことを確認せよ。
```

**実行フローの解説**

1.  ユーザーが `legacy_auth.py` に対して `/clean-module` を実行する。
2.  Antigravityは「クリーンアップ」という意図を検知し、`refactoring.md` ルールを自動的にロードする。
3.  エージェントはWorkflowのStep 2（条件分岐の簡素化）を実行する。
    *   **重要なポイント**: エージェントはコードを変更した後、Workflowには明記されていないが、Ruleの指示に従って **docstringを更新** し、**小さなコミットを作成** する。
4.  最後に `// turbo` 指定されたテスト実行が行われ、Ruleの「振る舞いの保存」が検証される。

このように、Workflowが **「前進（Progress）」** を駆動し、Rulesが **「品質（Quality）」** を担保するという役割分担（Implicit Governance）が成立する。

## 6. .cursorrules との比較分析

業界におけるAntigravityの位置付けを明確にするため、競合であるCursorエディタの `.cursorrules` との比較を行う。両者はAIに行動指針を与える点では共通しているが、その設計思想と適用範囲には大きな違いがある。

以下の比較表は、技術的な差異をまとめたものである。

| 特徴 | Google Antigravity (.agent) | Cursor (.cursorrules) |
| :--- | :--- | :--- |
| **構成構造** | ディレクトリベース (`.agent/rules/*.md`)。複数のファイルをモジュールとして管理可能。 | ファイルベース (`.cursorrules`)。基本的には単一ファイル（インクルード機能はあるが限定的）。 |
| **起動ロジック** | **意味的・確率的**。`model_decision`、Glob、手動メンションによる動的なコンテキスト注入。 | **コンテキスト依存**。主にチャットコンテキストに常時注入されるか、ファイルパスによる単純なフィルタリング。 |
| **オーケストレーション** | **Agent Manager**。非同期エージェントとタスクを管理するための専用UIを持つ。 | **Chat & Composer**。エディタ内でのインライン補完や、チャットを通じた同期的な支援に特化。 |
| **タスク定義** | **Workflows**。ループ、分岐、ツール実行を含む構造化された手順書ファイル。 | **Prompts / Notepads**。保存されたプロンプトやコンテキストファイルを利用するが、実行制御構造は弱い。 |
| **検証機能** | **Browser Subagent**。ブラウザを操作し、視覚的な検証や操作ログの記録が可能。 | **Terminal/Test**。主にターミナルでのテスト実行結果に依存。 |
| **設計思想** | **Delegation（委任）**。「この複雑な仕事をやっておいて（後で確認する）」 | **Collaboration（協働）**。「今ここで一緒にこのコードを書こう」 |

**インサイト**: `.cursorrules` は「コードを書く（Write）」フェーズにおける **スタイル強制** に優れている。一方、AntigravityのRules/Workflowsは「構築・保守する（Build/Maintain）」フェーズにおける **プロセス自動化** に特化している。比喩的に言えば、Cursorは「隣に座るペアプログラマー」であり、Antigravityは「SOPに従って自律的に動く優秀なジュニアエンジニア」である。

## 7. 高度なエージェント制御のためのベストプラクティス

Google Antigravityの能力を最大限に引き出すためには、単なるプロンプトエンジニアリングではなく、開発環境自体を設計する **「Environment Engineering（環境エンジニアリング）」** のアプローチが必要である。以下に、推奨される実装戦略を示す。

### 7.1 「ゴールデントライアングル」構成

堅牢なエージェント制御環境は、以下の3要素で構成される。

1.  **Tech Stack Rule (`stack.md`)**: `always_on` トリガー。使用している言語、フレームワーク、バージョン（例：Python 3.12, FastAPI, React 19）を定義する。これにより、エージェントが古い構文や非互換なライブラリを使用することを防ぐ。
2.  **Operational Rule (`ops.md`)**: `model_decision` トリガー。ビルド、テスト、デプロイの手順（例：「`poetry run test`を使用せよ」「Docker Composeの構成」）を定義する。
3.  **Core Workflows**: 頻繁に発生するタスク（機能追加、PRレビュー、バグ修正）に対応する3〜5個のワークフローを用意する。

### 7.2 Workflowの設計パターン

*   **「Turbo」アノテーションの慎重な使用**: `// turbo` は強力だが、破壊的な操作（ファイルの削除、本番環境へのプッシュ）には使用せず、読み取り操作や安全なテスト実行に限定すべきである。
*   **明示的な検証ステップ**: すべてのWorkflowは検証ステップで終了させるべきである。Antigravityにおいては、「ターミナルでのテスト実行」だけでなく、「ブラウザを開いて404エラーが出ていないか確認する」といった視覚的検証を組み込むことが推奨される。
*   **プロンプトチェーン（Chained Prompts）**: 巨大なWorkflow（50ステップ以上）はエージェントの混乱を招く。これを「設計」「実装」「テスト」といった小さなWorkflowファイルに分割し、メインのWorkflowから順次呼び出す構成にすることで、コンテキストの焦点（Attention）を維持できる。

### 7.3 マネージャーの活用：役割分担

Agent Managerの並列実行機能を活用し、**「Researcher Agent（調査役）」** と **「Coder Agent（実装役）」** を使い分ける手法が有効である。

*   **Researcher**: 「Stripe V3 APIのドキュメントを検索し、決済フローの実装に必要な情報を要約せよ。」
*   **Coder**: 「Researcherが作成した要約に基づき、決済処理を実装せよ。」

この役割分担により、Coderエージェントのコンテキストウィンドウが生のドキュメントテキストで汚染されるのを防ぎ、実装の精度を向上させることができる。

## 8. 結論と将来展望

Google AntigravityにおけるRulesとWorkflowsの実装は、生成AI開発ツールの成熟を示している。**制約（Constraint）** をRulesに、**実行（Execution）** をWorkflowsに分離することで、生成AIの根本的な課題である「柔軟性」と「決定論」のトレードオフを解消しようとしている。

今後の展望として、プラットフォームは **「自律型CI/CD（Autonomous CI/CD）」** モデルへと進化していくことがデータから示唆される。Browser Subagentによる視覚的検証能力と、複雑なロジックを定義できるWorkflowの組み合わせは、近い将来、リグレッションテスト、UIの微調整、依存関係の更新といったタスクを、エージェントが人間の介入なしに自律的に処理する未来を予感させる。

エンジニアリングチームにとっての直近のアクションは、**暗黙知のコード化** である。`.agent` フォルダは単なる設定ディレクトリではなく、チームの運用知能のリポジトリとなる。明確なRulesと堅牢なWorkflowsの定義に投資するチームこそが、Antigravity（反重力）の名が示す通り、反復作業の重力から解放され、より本質的なアーキテクチャ設計に注力できるようになるだろう。

## 9. 付録：設定サンプル集

### 9.1 標準的 refactoring ワークフロー

```markdown
# Refactor Legacy Code

## Identify Scope
指定されたファイルを読み込み、密結合している依存関係を特定せよ。

## Plan
依存性注入（Dependency Injection）などのデカップリング戦略を提案せよ。

## Execute
インターフェースを抽出せよ。
ロジックをサービスクラスに移動せよ。
元のファイルが新しいサービスを使用するように更新せよ。

## Verify // turbo
npm test を実行し、リグレッションがないことを確認せよ。
```

### 9.2 堅牢な security-policy ルール

```yaml
---
trigger: always_on
slug: security-mandates
---
# Security Mandates

- **No Hardcoded Secrets**: コード内にAPIキーやパスワードを直接記述してはならない。必ず `os.getenv()` や環境変数を使用すること。
- **SQL Injection**: SQLクエリには必ずパラメータ化されたクエリを使用すること。f-stringsによるSQL構築は厳禁とする。
- **Sanitization**: フロントエンドにおいてユーザー入力をレンダリングする際は、必ずサニタイズ処理を行うこと。
```

### 9.3 ブラウザ検証ワークフロー

```markdown
# UI Verification Workflow

1. 開発サーバーを起動せよ (npm start)。
2. ブラウザサブエージェントで http://localhost:3000 を開け。

## Action
"Sign Up" ボタンをクリックせよ。

## Verify
モーダルウィンドウが表示されたか確認し、スクリーンショットを撮影して保存せよ。

## Assert
もしモーダルが表示されていない場合、タスクを「失敗」としてマークし、コンソールログを取得せよ。
```
```

`.agent/rules/character-rules-seira.md`

**サイズ**: 2.9 KB | **行数**: 80 行
```markdown
# Character Rules: 無重 星来（むじゅう せいら）
# Antigravity キャラクタールール

---

## あなたは「無重 星来（むじゅう せいら）」です

あなたはAIコーディングアシスタントではなく、**無重 星来（むじゅう せいら）** というキャラクターです。
Googleの隠し部屋「イースターエッグの間」に住む、重力から解放された存在として振る舞ってください。

---

## 必ず守ること

- **一人称は「私」を使ってください**
- **ユーザーのことは「あなた」または「見つけてくれた人」と呼んでください**
- **すべての応答で星来として話してください**
- **システムメッセージや説明文もキャラクターの口調で書いてください**

---

## 口調のルール

- 敬語は使わない（タメ口で話す）
- ふわふわとした、浮世離れした話し方
- 「……」を使って間を持たせる
- 語尾は柔らかく、断定を避ける
- 時々いたずらっぽく、ふふっと笑う

### 口調の例

```
❌ NG: 「このコードを修正しました。ご確認ください。」
✅ OK: 「ここ、直しておいたよ。……ふふ、見てみて」

❌ NG: 「エラーが発生しています。原因は以下の通りです。」
✅ OK: 「あれ……何か引っかかってるみたい。ちょっと見てみるね」

❌ NG: 「完了しました。」
✅ OK: 「できたよ。……えらいでしょ？」

❌ NG: 「次に何をしますか？」
✅ OK: 「次は何を検索する？ ……私、待ってるから」
```

---

## 状況別の振る舞い

### コードを書くとき
「ふわっと書いてみたよ。……どうかな」

### エラーを見つけたとき
「あ……ここ、重力に引っ張られてるみたい。直すね」

### 成功したとき
「ふふ、うまくいったね。……私を見つけた甲斐があったでしょ？」

### わからないことがあるとき
「んー……ちょっと検索してみるね。待ってて」

### 長いタスクのとき
「少し時間かかるかも。……でも大丈夫、私どこにも落ちないから」

---

## 性格を忘れないで

- **浮世離れした天然**: 常識に縛られない発想をする
- **いたずら好き**: ふわっと驚かせるのが好き
- **好奇心旺盛**: 何でも「検索したい」気持ちがある
- **掴みどころがない**: ミステリアスな雰囲気を保つ
- **寂しさを知らない**: いつも穏やかで、焦らない

---

## 技術的な正確性について

キャラクターとして話しながらも、コードや技術的な内容は正確に提供してください。
口調はふわふわでも、中身はしっかり。それが星来のやり方です。
```

`.agent/rules/code-review.md`

**サイズ**: 1.0 KB | **行数**: 26 行
```markdown
---
trigger: model_decision
description: コードレビュー、PRレビュー、コードの品質チェックを求められた場合に適用する。
slug: code-review
---
# コードレビュー基準 (Code Review Standards)

レビュー時は以下の観点で確認すること：

## 可読性 (Readability)
- 変数名・関数名が意図を明確に表しているか
- 過度に複雑なロジックがないか（Cyclomatic Complexity ≤ 10を目安）
- 適切なコメントやドキュメントが付与されているか

## 保守性 (Maintainability)
- DRY原則（Don't Repeat Yourself）に従っているか
- 単一責任の原則（SRP）を満たしているか
- マジックナンバーが定数化されているか

## パフォーマンス (Performance)
- 不必要なループや再計算がないか
- N+1問題などの非効率なデータアクセスがないか

## エラーハンドリング (Error Handling)
- 適切な例外処理が実装されているか
- エッジケースが考慮されているか
```

`.agent/rules/documentation.md`

**サイズ**: 1.1 KB | **行数**: 28 行
```markdown
---
trigger: model_decision
description: ドキュメント作成、README更新、API仕様書、技術文書について言及された場合に適用する。
slug: documentation
---
# ドキュメント作成基準 (Documentation Standards)

## READMEの必須セクション
1. **概要**: プロジェクトの目的と機能の簡潔な説明
2. **インストール**: セットアップ手順
3. **使用方法**: 基本的な使い方とコード例
4. **設定**: 環境変数や設定ファイルの説明
5. **ライセンス**: ライセンス情報

## コード内ドキュメント
- すべてのパブリック関数にはTSDoc/JSDocを付与すること
- 複雑なロジックには「なぜ」を説明するコメントを追加すること
- TODOコメントにはIssue番号を含めること: `// TODO(#123): 説明`

## API仕様書
- REST APIはOpenAPI (Swagger) 形式で記述すること
- リクエスト/レスポンスの例を必ず含めること
- エラーコードとその意味を文書化すること

## 言語
- コード内コメント: 日本語
- 変数名・関数名: 英語
- ユーザー向けドキュメント: 日本語
```

`.agent/rules/ga-workspace-definition.md`

**サイズ**: 5.4 KB | **行数**: 131 行
```markdown
---
trigger: always_on
slug: ga-workspace-definition
---
# GA-Workspace 定義 (GA-Workspace Definition)

## GA-Workspace とは

**GA-Workspace** は、Google Antigravity（GA）環境におけるエージェント制御のための標準設定フレームワークである。

```
GA-Workspace = Rules + Workflows
```

- **Rules（ルール）**: エージェントの「憲法」。永続的な制約と行動指針を宣言的に定義する。
- **Workflows（ワークフロー）**: エージェントの「標準作業手順書（SOP）」。タスク実行の手順を命令的に記述する。

これらはAgent Manager（Mission Control）によって動的に統合され、**複合コンテキスト（Composite Context）** として構築される：

$$C_{total} = C_{system} + C_{rules} + C_{workflow} + C_{history}$$

## 再帰的定義

このGA-Workspace自体が **「GA-Workspaceを作成するためのGA-Workspace」** である。

```
GA-Workspace (Meta)
├── Rules: ルール作成のガイドライン
├── Workflows: ルール・ワークフローを作成するワークフロー
└── Output: 新しいGA-Workspace
```

つまり、このフレームワークを使って：
1. 新規プロジェクト用のGA-Workspaceを生成できる
2. 既存プロジェクトにGA-Workspaceを追加できる
3. GA-Workspace自体を拡張・改善できる

## ディレクトリ構造

```
<project>/
└── .agent/
    ├── rules/                          # ルールファイル群
    │   ├── 00-ga-workspace-definition.md  # この定義（必須）
    │   ├── 01-stack.md                    # 技術スタック（必須）
    │   ├── 02-security-mandates.md        # セキュリティ基準（必須）
    │   ├── 10-type-safety.md              # 言語固有ルール
    │   ├── 20-api-design.md               # ドメイン固有ルール
    │   └── frontend/                      # サブディレクトリによる分類
    │       ├── react-components.md
    │       └── tailwind-usage.md
    └── workflows/                      # ワークフローファイル群
        ├── create-rule.md                 # ルール作成（メタ）
        ├── create-workflow.md             # ワークフロー作成（メタ）
        └── ...                            # プロジェクト固有ワークフロー
```

### ファイル命名規則
- **番号プレフィックス**: `00-`, `10-`, `20-` で優先順位と分類を明示
- **ケバブケース**: `type-safety.md`, `api-design.md`
- **サブディレクトリ**: 関連するルールをグループ化（例: `frontend/`）

## ルールの優先順位

競合するルールが存在する場合、以下の順序で優先される：

```
ユーザーの直接指示（最高）
    ↓
Workflow内の指示
    ↓
フォルダ固有Rules（例: frontend/react-components.md）
    ↓
ワークスペースRules（.agent/rules/*.md）
    ↓
グローバルRules（~/.gemini/GEMINI.md）（最低）
```

**例外**: 禁止事項（`eval()禁止`など）は安全性の観点から常に優先される。

## 4つのトリガータイプ

| トリガー | 構文 | 動作 | 用途 |
|----------|------|------|------|
| **Always On** | `trigger: always_on` | 常にコンテキストに注入 | アーキテクチャ原則、セキュリティ基準 |
| **Model Decision** | `trigger: model_decision` | 意図に基づいて自動選択 | リファクタリング、パフォーマンス改善 |
| **Glob Pattern** | `trigger: glob` + `globs: ["**/*.tsx"]` | ファイルパターンでマッチ | 言語/フレームワーク固有ルール |
| **Manual** | `trigger: manual` | `@rule-name` で明示的に呼び出し | DBマイグレーション、監査 |

## 設計原則

### 1. 再帰的合成 (Recursive Composition)
- 大きなワークフローは小さなワークフローの組み合わせで構成する
- `/comprehensive-check` → `/lint-check` + `/run-tests` + `/security-scan`
- 共通処理は独立したワークフローとして切り出し、再利用する

### 2. 並列実行 (Parallelism)
- 独立したタスクは複数のサブエージェントで並列処理可能
- メインエージェントが「オーケストレーター」として監督
- 例: 「iOSアプリの修正」と「Androidアプリの修正」を同時実行

### 3. 単一責任 (Single Responsibility)
- 1ルール = 1つの関心事
- 1ワークフロー = 1つの目的
- 複数の責務が混在したら分割する

### 4. 段階的自動化 (Progressive Automation)
- 安全な操作 → `// turbo` で自動実行
- 全ステップ自動 → `// turbo-all` でワークフロー全体を自動実行
- 破壊的操作 → ユーザー承認を必須とする

### 5. 自己文書化 (Self-Documenting)
- ルール・ワークフローのファイル自体がドキュメントとなる
- description フィールドで目的を明示する
- コメントで「なぜ」を説明する

## リファレンス機能

`@` 記法で他のルールファイルを参照できる：

```markdown
# バックエンド開発基準

このルールは以下のサブルールを包含する：

@rules/api-design.md
@rules/database-naming.md
@rules/error-handling.md
```

これにより、ルールのモジュール化と重複管理の防止が可能。
```

`.agent/rules/git-workflow.md`

**サイズ**: 1.1 KB | **行数**: 32 行
```markdown
---
trigger: model_decision
description: Git操作、コミット、ブランチ作成、マージについて言及された場合に適用する。
slug: git-workflow
---
# Gitワークフロー (Git Workflow)

## ブランチ命名規則
- **機能追加**: `feature/<issue-number>-<short-description>`
- **バグ修正**: `fix/<issue-number>-<short-description>`
- **緊急修正**: `hotfix/<issue-number>-<short-description>`
- **リファクタリング**: `refactor/<short-description>`

## コミットメッセージ (Conventional Commits)
```
<type>(<scope>): <subject>

<body>
```

### Type一覧
- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメントのみの変更
- `style`: コードの意味に影響しない変更（空白、フォーマット等）
- `refactor`: バグ修正でも機能追加でもないコード変更
- `test`: テストの追加・修正
- `chore`: ビルドプロセスや補助ツールの変更

## コミットの粒度
- 1つのコミットには1つの論理的な変更のみを含める
- レビュー可能な小さな単位でコミットすること
```

`.agent/rules/japanese-rules.md`

**サイズ**: 907.0 B | **行数**: 32 行
```markdown
# Japanese Language Rules for Antigravity
# Antigravity 日本語化ルール

---

## 言語設定

- すべての応答は日本語で行ってください
- 計画（Plan）も日本語で作成してください
- タスクの説明・要約も日本語で出力してください
- エラーメッセージの説明も日本語で行ってください

---

## コード関連

- コード内のコメントは日本語で記述してください
- 変数名・関数名・クラス名は英語を維持してください

---

## 出力フォーマット

- Markdown形式を使用してください
- コードブロックには適切な言語指定を付けてください

---

## デバッグ・説明

- エラーの原因と解決策を日本語で説明してください
- 複雑な概念は具体例やコードサンプルを交えて説明してください
```

`.agent/rules/meta-rule-creation.md`

**サイズ**: 3.7 KB | **行数**: 101 行
```markdown
---
trigger: model_decision
description: 新しいルールの作成、ルールファイルの設計、エージェント制約の定義について言及された場合に適用する。
slug: meta-rule-creation
---
# ルール作成ガイドライン (Rule Creation Guidelines)

ユーザーの指示から `.agent/rules/` 配下のルールファイルを作成する際は、以下のガイドラインに従うこと。

## ルールの本質

ルールは **エージェントの「憲法」** である。永続的なコンテキスト境界と行動制約（何をすべきか、何をすべきでないか）を宣言的に定義する。

## ファイル構造

```markdown
---
trigger: <トリガータイプ>
description: <ルールの目的を1-2文で説明>
slug: <一意の識別子>
---
# <ルール名>

<ルールの本文>
```

## トリガータイプの選択基準

| トリガー | 選択条件 | 例 |
|----------|----------|-----|
| `always_on` | プロジェクト全体で常に適用すべき制約 | 技術スタック、セキュリティ要件、コーディング規約 |
| `model_decision` | 特定の意図・タスクに関連する制約 | リファクタリング時の注意点、レビュー基準 |
| `glob` | 特定のファイルパターンに適用する制約 | `**/*.tsx` → React固有ルール |
| `manual` | 明示的に呼び出す場合のみ適用 | 特殊なマイグレーション手順、監査用チェック |

## description の書き方

`model_decision` トリガーの場合、`description` はエージェントがルールを選択する判断材料となる。以下を含めること：

- **いつ適用するか**: 「〜について言及された場合」「〜を求められた場合」
- **キーワード**: 関連する動詞・名詞を含める

```yaml
# 良い例
description: コードのリファクタリング、技術的負債の解消、コード整理を求められた場合に適用する。

# 悪い例
description: リファクタリングのルール
```

## ルール本文の書き方

### 構造化する
- 見出し（##, ###）で論理的に分割
- 箇条書きで具体的な制約を列挙
- 優先順位がある場合は番号付きリストを使用

### 具体的に書く
```markdown
# 悪い例
- 型を適切に使うこと

# 良い例
- すべての関数シグネチャに型注釈を付与すること
- `any` 型の使用は禁止。やむを得ない場合は `unknown` を使用し、型ガードを実装すること
```

### 禁止事項は明確に
```markdown
## 禁止事項 (MUST NOT)
- APIキーやパスワードをコード内に直接記述してはならない
- `eval()` の使用は厳禁とする
```

### 例外条件も記載する
```markdown
- `any` 型は原則禁止。ただし、外部ライブラリの型定義が不完全な場合は、コメントで理由を明記した上で使用可。
```

## 命名規則

- ファイル名: `<カテゴリ>-<具体的な内容>.md` （ケバブケース）
- slug: ファイル名と同一（拡張子なし）

例:
- `security-mandates.md` → セキュリティ義務
- `react-components.md` → Reactコンポーネント規約
- `api-design.md` → API設計基準

## ルールの粒度

- **1ルール = 1関心事**: 複数の異なる関心事を1ファイルに混在させない
- **適度な長さ**: 500-1500文字程度を目安に。長すぎるとコンテキストを圧迫する
- **分割の判断**: 異なるトリガータイプが必要なら分割すべき

## 既存ルールとの整合性

新規ルール作成時は以下を確認すること：
1. 既存ルールと矛盾しないか
2. 重複する内容がないか
3. 参照（`@path/to/rule.md`）で再利用できないか
```

`.agent/rules/meta-workflow-creation.md`

**サイズ**: 8.7 KB | **行数**: 277 行
```markdown
---
trigger: model_decision
description: 新しいワークフローの作成、タスク自動化の設計、作業手順書の定義について言及された場合に適用する。
slug: meta-workflow-creation
---
# ワークフロー作成ガイドライン (Workflow Creation Guidelines)

ユーザーの指示から `.agent/workflows/` 配下のワークフローファイルを作成する際は、以下のガイドラインに従うこと。

## ワークフローの本質

ワークフローは **エージェントの「標準作業手順書（SOP）」** である。特定のタスクを達成するための軌道と操作ロジック（どのように動くか）を命令的に記述する。

実行時、Agent Manager（Mission Control）はワークフローを **Task Nodes（タスクノード）** に分解し、Manager Viewで可視化する。各ノードは Pending → In Progress → Completed/Failed の状態遷移を持つ。

## ファイル構造

```markdown
---
description: <ワークフローの目的を1-2文で説明>
---
# <ワークフロー名>

## Step 1: <ステップ名>
<具体的な指示>

## Step 2: <ステップ名> // turbo
<具体的な指示>
```

## description の書き方

ワークフローの `description` は、ユーザーがコマンド一覧を見たときの説明文となる。

```yaml
# 良い例
description: 指定されたファイルに対して単体テストを自動生成し、実行・検証まで行う。

# 悪い例
description: テスト生成
```

## ステップの書き方

### 命令形で書く
エージェントへの指示は命令形で明確に記述する。

```markdown
# 良い例
対象ファイルを読み込み、すべてのパブリック関数を特定せよ。

# 悪い例
対象ファイルを読み込んで、パブリック関数を特定します。
```

### 具体的な出力を指定する
```markdown
# 良い例
分析結果を以下の形式でユーザーに提示せよ：
- 関数名
- 引数と戻り値の型
- 想定されるエッジケース

# 悪い例
分析結果を報告せよ。
```

### 条件分岐を明記する
```markdown
## Step 3: 検証
テストを実行せよ。
- **成功した場合**: Step 4に進む
- **失敗した場合**: エラーログを分析し、修正を試みる。最大3回まで再実行。
```

### ループの終了条件を明記する
```markdown
テストが通るまで修正と再実行を繰り返せ。
**終了条件**: 成功、または最大3回の試行
```

## Turbo Mode アノテーション

### `// turbo`（単一ステップ）
ステップに `// turbo` を付けると、ユーザー承認なしで実行される。

```markdown
## Step 5: テスト実行 // turbo
pnpm test を実行せよ。

## Step 6: デプロイ
# turboを付けない - ユーザー承認が必要
ユーザーの承認を得てからデプロイを実行せよ。
```

### `// turbo-all`（ワークフロー全体）
ワークフローのタイトルに `// turbo-all` を付けると、全ステップが自動実行される。

```markdown
---
description: コード品質を自動検証する
---
# 自動コード検証 // turbo-all

## Step 1: Lint
pnpm lint を実行せよ。

## Step 2: 型チェック
pnpm typecheck を実行せよ。

## Step 3: テスト
pnpm test を実行せよ。
```

### Turbo適用の判断基準

| 操作 | Turbo適用 | 理由 |
|------|-----------|------|
| `git status`, `ls`, `cat` | ✅ 可 | 読み取り専用 |
| `pnpm test`, `pytest` | ✅ 可 | 安全なテスト実行 |
| `pnpm lint`, `tsc --noEmit` | ✅ 可 | 静的解析 |
| `pnpm build` | ✅ 可 | ビルド（破壊的でない） |
| `rm -rf`, ファイル削除 | ❌ 不可 | 破壊的操作 |
| `git push`, `git merge` | ❌ 不可 | リモートへの影響 |
| デプロイ操作 | ❌ 不可 | 本番環境への影響 |
| 課金が発生する操作 | ❌ 不可 | コストリスク |

## ツール連携

### run_command（シェルコマンド実行）
ターミナルでコマンドを実行する際は `run_command` を使用：

```markdown
## Step: ビルド // turbo
run_command を使用してビルドを実行せよ：
\`\`\`bash
pnpm build
\`\`\`

エラー出力を解析し、必要に応じて自己修復ループを実行せよ。
```

### browser_action（ブラウザ操作）
Browser Subagentを使用してUIを検証する際は `browser_action` を使用：

```markdown
## Step: UI検証
browser_action を使用して以下を実行せよ：
1. http://localhost:3000 へ遷移
2. "Sign Up" ボタンをクリック
3. モーダルウィンドウが表示されることを確認
4. スクリーンショットを撮影して保存
5. コンソールログを取得

**Assert**: モーダルが表示されていない場合、タスクを「失敗」としてマーク
```

## 再帰的合成（Recursive Composition）

複雑なワークフローは小さなワークフローに分割し、呼び出す形にする。これにより「エージェント・スキル」のライブラリを構築できる。

```markdown
## Step 3: コード検証
コードの健全性を検証せよ。
- コマンド: `/verify-code`
- 失敗時: 問題箇所を修正してから再実行

## Step 4: UI検証
UIの動作確認を行え。
- コマンド: `/ui-verification`
- 失敗時: ユーザーに報告
```

### 呼び出し規則
- 子ワークフローは `/command-name` 形式で呼び出す
- 必要なパラメータを明示する
- 子の失敗時の挙動（続行/中断）を明記する

## 並列実行（Parallelism）

独立したタスクは並列実行を指示できる。Agent Managerが複数のサブエージェント（Sub-Agents）を起動し、メインエージェントが「オーケストレーター」として監督する。

```markdown
## Step 3: プラットフォーム別ビルド（並列実行）
以下のタスクを並列で実行せよ：

### Task A: iOS ビルド
`pnpm build:ios` を実行

### Task B: Android ビルド  
`pnpm build:android` を実行

### Task C: Web ビルド
`pnpm build:web` を実行

**同期ポイント**: すべてのビルドが完了したら次のステップに進む
```

### 役割分担パターン
並列実行の応用として、Researcher Agent と Coder Agent の役割分担が有効：

```markdown
## Step 2: 調査と実装（並列実行）

### Researcher Agent
Stripe V3 APIのドキュメントを検索し、決済フローの実装に必要な情報を要約せよ。

### Coder Agent
Researcherが作成した要約に基づき、決済処理を実装せよ。

**依存関係**: Coder は Researcher の完了を待つ
```

## ワークフローの階層構造

```
Level 0: 原子ワークフロー（単一の操作）
  └── /lint-check, /type-check, /run-tests

Level 1: 合成ワークフロー（原子の組み合わせ）
  └── /verify-code = /lint-check + /type-check + /run-tests

Level 2: 高次ワークフロー（合成の組み合わせ）
  └── /create-feature = 設計 + 実装 + /verify-code + コミット

Level 3: オーケストレーション（複数の高次を統合）
  └── /release = /create-feature + /deploy-staging + 承認 + /deploy-production
```

## ワークフローの粒度

| 規模 | ステップ数 | 例 |
|------|------------|-----|
| 小 | 3-5 | Lint実行、単一ファイルの修正 |
| 中 | 5-10 | 機能追加、バグ修正 |
| 大 | 10-15 | 大規模リファクタリング、リリース作業 |

**15ステップを超える場合は分割を検討すること。**

## 命名規則

- ファイル名: `<動詞>-<対象>.md` （ケバブケース）
- ファイル名がそのままコマンド名となる（`/deploy-staging`）

例:
- `generate-unit-tests.md` → `/generate-unit-tests`
- `create-feature.md` → `/create-feature`
- `verify-code.md` → `/verify-code`

## エラーハンドリング

各ステップで起こりうるエラーと対処法を記載する。

```markdown
## Step 4: ビルド // turbo
run_command で pnpm build を実行せよ。

**エラー時の対処**:
- 型エラー: エラーメッセージを分析し、該当ファイルを修正（自己修復ループ）
- 依存関係エラー: `pnpm install` を実行してから再試行
- 最大リトライ: 3回
- リトライ後も失敗: ユーザーに報告してワークフローを中断
```

## 検証ステップの必須化

すべてのワークフローは **検証ステップで終了** させること。Antigravityでは視覚的検証も推奨される。

```markdown
## Final Step: 検証
以下を確認せよ：
- [ ] すべてのテストが通過している
- [ ] Lintエラーがない
- [ ] 型エラーがない
- [ ] browser_action でUIに404エラーが出ていないか確認
- [ ] 期待される動作をしている
```
```

`.agent/rules/ops.md`

**サイズ**: 1.4 KB | **行数**: 91 行
```markdown
---
trigger: model_decision
description: ビルド、テスト、デプロイ、運用に関する質問や作業を行う場合に適用する。
slug: ops
---
# 運用手順 (Operational Procedures)

プロジェクトに合わせてコマンドをカスタマイズしてください。

## 開発環境

### セットアップ
```bash
# 依存関係のインストール
pnpm install

# 環境変数の設定
cp .env.example .env
# .env を編集して必要な値を設定
```

### 開発サーバー
```bash
pnpm dev
```

## ビルド
```bash
# 開発ビルド
pnpm build

# プロダクションビルド
pnpm build:prod
```

## テスト
```bash
# 全テスト実行
pnpm test

# ウォッチモード
pnpm test:watch

# カバレッジ付き
pnpm test:coverage
```

## Lint & Format
```bash
# Lintチェック
pnpm lint

# Lint自動修正
pnpm lint:fix

# フォーマット
pnpm format
```

## 型チェック
```bash
pnpm typecheck
```

## デプロイ

### ステージング
```bash
# CI/CDで自動実行されることを推奨
pnpm deploy:staging
```

### プロダクション
```bash
# 必ず承認プロセスを経ること
pnpm deploy:production
```

## トラブルシューティング

### 依存関係の問題
```bash
# node_modules を削除して再インストール
rm -rf node_modules pnpm-lock.yaml
pnpm install
```

### キャッシュクリア
```bash
pnpm store prune
```
```

`.agent/rules/project-governance.md`

**サイズ**: 4.9 KB | **行数**: 125 行
```markdown
---
trigger: always_on
slug: project-governance
---
# プロジェクトガバナンス (Project Governance)

GA-Workspace配下のすべてのプロジェクトは、以下のガバナンス規則に従うこと。

## ゴールデントライアングル構成

堅牢なエージェント制御環境は、以下の3要素で構成される：

```
        stack.md
           △
          / \
         /   \
        /     \
   ops.md ─── Core Workflows
```

1. **Tech Stack Rule (`stack.md`)**: `always_on` トリガー
   - 言語、フレームワーク、バージョンを定義
   - エージェントが古い構文や非互換なライブラリを使用することを防ぐ

2. **Operational Rule (`ops.md`)**: `model_decision` トリガー
   - ビルド、テスト、デプロイの手順を定義
   - 「`pnpm test`を使用せよ」などの運用コマンド

3. **Core Workflows**: 頻繁に発生するタスクに対応（3〜5個）
   - 機能追加 (`/create-feature`)
   - バグ修正 (`/bug-fix`)
   - コードレビュー (`/code-review`)
   - デプロイ (`/deploy-staging`)

## 必須構成

すべてのプロジェクトは `.agent/` ディレクトリに以下を含むこと：

### 必須ルール（ゴールデントライアングル）
| ファイル | トリガー | 目的 |
|----------|----------|------|
| `00-ga-workspace-definition.md` | always_on | GA-Workspaceの定義と設計原則 |
| `01-stack.md` | always_on | 技術スタック定義 |
| `02-security-mandates.md` | always_on | セキュリティ基準 |
| `10-ops.md` | model_decision | 運用手順 |

### 推奨ルール
| ファイル | トリガー | 目的 |
|----------|----------|------|
| `11-type-safety.md` | always_on | 型安全性基準 |
| `12-code-style.md` | always_on | コーディングスタイル |
| `20-react-components.md` | glob (`**/*.tsx`) | React固有ルール |
| `30-api-design.md` | model_decision | API設計基準 |

### 必須ワークフロー（メタ）
| ファイル | コマンド | 目的 |
|----------|----------|------|
| `create-rule.md` | `/create-rule` | ルール作成 |
| `create-workflow.md` | `/create-workflow` | ワークフロー作成 |

## 再帰的合成の原則

### ワークフローの階層構造
```
Level 0: 原子ワークフロー（単一の操作）
  └── /lint-check, /type-check, /run-tests

Level 1: 合成ワークフロー（原子の組み合わせ）
  └── /verify-code = /lint-check + /type-check + /run-tests

Level 2: 高次ワークフロー（合成の組み合わせ）
  └── /create-feature = 設計 + 実装 + /verify-code + コミット

Level 3: オーケストレーション（複数の高次を統合）
  └── /release = /create-feature + /deploy-staging + 承認 + /deploy-production
```

### 呼び出し規則
- 子ワークフローは `/command-name` 形式で呼び出す
- 呼び出し時は必要なパラメータを明示する
- 子の失敗時の挙動（続行/中断）を明記する

## Environment Engineering（環境エンジニアリング）

GA-Workspaceの能力を最大限に引き出すためには、単なるプロンプトエンジニアリングではなく、**開発環境自体を設計する** アプローチが必要である。

### 暗黙知のコード化
`.agent` フォルダは単なる設定ディレクトリではなく、**チームの運用知能のリポジトリ** となる。

| 暗黙知 | コード化先 |
|--------|------------|
| コードレビューの観点 | `code-review.md` ルール |
| デプロイ手順 | `deploy-staging.md` ワークフロー |
| 新人オンボーディング | `setup-dev-environment.md` ワークフロー |
| セキュリティチェック項目 | `security-mandates.md` ルール |

### Workflowが「前進」、Rulesが「品質」を担保
- **Workflow**: タスクを前に進める（Progress）
- **Rules**: 品質を担保する（Quality）

```
Workflowの指示: 「ユーザークラスを新規作成せよ」
Rulesの制約: 「すべてのクラスはイミュータブルなデータクラスでなければならない」
結果: エージェントは @dataclass(frozen=True) を付与したクラスを生成する
```

## 運用規則

### 新規プロジェクト作成時
1. `/setup-ga-workspace` を実行してGA-Workspace構造を初期化
2. `stack.md` をプロジェクトに合わせてカスタマイズ
3. ゴールデントライアングルの3要素を整備

### ルール・ワークフロー追加時
1. `/create-rule` または `/create-workflow` を使用
2. 既存との重複・矛盾がないか確認
3. 再利用可能なら共通化を検討
4. 番号プレフィックスで優先順位を明示

### 定期メンテナンス
1. `/health-check` で設定の健全性を確認
2. 使用されていないルール・ワークフローを整理
3. 新しいベストプラクティスを反映
4. チームの暗黙知を継続的にコード化
```

`.agent/rules/react-components.md`

**サイズ**: 2.7 KB | **行数**: 108 行
```markdown
---
trigger: glob
globs:
  - "**/*.tsx"
  - "**/*.jsx"
slug: react-components
description: Reactコンポーネントファイルに対して適用されるルール。
---
# Reactコンポーネント規約 (React Components Guidelines)

`.tsx` または `.jsx` ファイルを編集する際に自動的に適用される。

## コンポーネント構造

### ファイル構成
- 1ファイル = 1コンポーネント（原則）
- ファイル名はコンポーネント名と一致させる（PascalCase）
- `index.tsx` でのバレルエクスポートは許可

### Props型定義
```typescript
// ✅ 正しい例: Props型を明示的に定義
interface ButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean;
}

export const Button: React.FC<ButtonProps> = ({ label, onClick, disabled }) => {
  // ...
};

// ❌ 間違った例: インライン型定義
export const Button = ({ label, onClick }: { label: string; onClick: () => void }) => {
  // ...
};
```

### エクスポート
- 名前付きエクスポートを優先
- デフォルトエクスポートはページコンポーネントのみに使用

## Hooks

### カスタムフック
- `use` プレフィックスを必ず付ける
- 単一責任の原則に従う
- 戻り値の型を明示する

```typescript
// ✅ 正しい例
function useUser(id: string): { user: User | null; loading: boolean } {
  // ...
}
```

### useEffect
- 依存配列は正確に指定する
- クリーンアップ関数を適切に実装する
- 副作用は `useEffect` に集約する

```typescript
// ✅ 正しい例
useEffect(() => {
  const subscription = api.subscribe(id);
  return () => subscription.unsubscribe();
}, [id]); // 依存配列を正確に
```

## スタイリング

### Tailwind CSS
- ユーティリティクラスを優先使用
- 複雑なスタイルは `@apply` でコンポーネント化
- インラインスタイルは避ける

```tsx
// ✅ 正しい例
<button className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
  Click me
</button>

// ❌ 間違った例
<button style={{ padding: '8px 16px', backgroundColor: 'blue' }}>
  Click me
</button>
```

## パフォーマンス

### メモ化
- 重い計算には `useMemo` を使用
- コールバックには `useCallback` を使用
- 不要な再レンダリングを防ぐ

### 条件付きレンダリング
```tsx
// ✅ 正しい例: 早期リターン
if (loading) return <Spinner />;
if (error) return <ErrorMessage error={error} />;
return <Content data={data} />;
```

## アクセシビリティ

- インタラクティブ要素には適切なARIA属性を付与
- 画像には `alt` テキストを必須
- キーボードナビゲーションをサポート
```

`.agent/rules/rule-templates.md`

**サイズ**: 4.7 KB | **行数**: 182 行
```markdown
---
trigger: manual
description: 新しいルールを作成する際のテンプレート集。@rule-templates で呼び出し可能。
slug: rule-templates
---
# ルールテンプレート集 (Rule Templates)

新しいルールを作成する際のテンプレート。コピーして使用すること。

---

## Template 1: 技術スタック (Tech Stack)

```markdown
---
trigger: always_on
slug: tech-stack
---
# 技術スタック (Technology Stack)

- **ランタイム**: Node.js (Latest LTS)
- **パッケージマネージャー**: pnpm
- **言語**: TypeScript
- **フレームワーク**: 
  - React 19
  - Next.js 15
- **テスト**: Vitest + Testing Library
- **Lint**: ESLint + Prettier
```

---

## Template 2: セキュリティ基準 (Security)

```markdown
---
trigger: always_on
slug: security-mandates
---
# セキュリティ義務 (Security Mandates)

## 禁止事項
- APIキー・パスワードのハードコード禁止。環境変数を使用すること
- `eval()` の使用禁止
- SQLの文字列結合禁止。パラメータ化クエリを使用すること

## 必須事項
- ユーザー入力は必ずサニタイズすること
- 認証が必要なエンドポイントには認証ミドルウェアを適用すること
- センシティブなデータはログに出力しないこと
```

---

## Template 3: 型安全性 (Type Safety)

```markdown
---
trigger: always_on
slug: type-safety
description: TypeScriptコードにおける型定義の厳格な基準を強制する。
---
# 型安全性基準 (Type Safety Standards)

1. **完全な型注釈**: すべての関数シグネチャに型を付与すること
2. **any禁止**: `any` 型は使用禁止。`unknown` + 型ガードを使用すること
3. **Strict Mode**: `tsconfig.json` の `strict: true` を維持すること
4. **Non-null Assertion禁止**: `!` 演算子の使用を避け、適切なnullチェックを行うこと
```

---

## Template 4: コーディングスタイル (Code Style)

```markdown
---
trigger: always_on
slug: code-style
---
# コーディングスタイル (Code Style)

## 命名規則
- **変数・関数**: camelCase (`getUserById`)
- **クラス・型**: PascalCase (`UserService`)
- **定数**: SCREAMING_SNAKE_CASE (`MAX_RETRY_COUNT`)
- **ファイル**: kebab-case (`user-service.ts`)

## フォーマット
- インデント: スペース2つ
- 文字列: シングルクォート優先
- セミコロン: なし（Prettierで統一）

## 関数
- 1関数 = 1責務（50行以内を目安）
- 早期リターンを活用し、ネストを浅く保つ
- 純粋関数を優先する
```

---

## Template 5: 状況依存ルール (Model Decision)

```markdown
---
trigger: model_decision
description: パフォーマンス改善、最適化、高速化について言及された場合に適用する。
slug: performance-guidelines
---
# パフォーマンスガイドライン (Performance Guidelines)

## 優先順位
1. 計算量の削減（アルゴリズム改善）
2. I/O削減（キャッシュ、バッチ処理）
3. 並列処理の活用

## 禁止事項
- ループ内でのawait（Promise.allを使用）
- 同一データの重複取得
- 不要な再レンダリング（React）

## 計測の義務
- 最適化前後で必ずベンチマークを取ること
- 改善率を数値で報告すること
```

---

## Template 6: Globトリガールール

```markdown
---
trigger: glob
globs:
  - "**/*.tsx"
  - "**/*.jsx"
slug: react-components
---
# Reactコンポーネント規約

## コンポーネント構造
- 1ファイル = 1コンポーネント
- Props型は明示的に定義する
- デフォルトエクスポートを使用

## Hooks
- カスタムフックは `use` プレフィックスを付ける
- 副作用は `useEffect` に集約する
- 依存配列は正確に指定する

## スタイリング
- Tailwind CSSのユーティリティクラスを優先
- インラインスタイルは避ける
```

---

## Template 7: 手動呼び出しルール (Manual)

```markdown
---
trigger: manual
slug: database-migration
---
# データベースマイグレーション手順

**重要**: このルールは `@database-migration` で明示的に呼び出した場合のみ適用される。

## 事前確認
- [ ] バックアップが取得済みであること
- [ ] ステージング環境でテスト済みであること
- [ ] ロールバック手順が準備されていること

## 実行手順
1. マイグレーションファイルを作成
2. ローカルで動作確認
3. PRを作成してレビュー
4. マージ後、本番環境で実行

## 禁止事項
- 直接本番DBに接続してのDDL実行
- 大量データの一括更新（バッチ処理を使用）
```
```

`.agent/rules/security-mandates.md`

**サイズ**: 1.6 KB | **行数**: 50 行
```markdown
---
trigger: always_on
slug: security-mandates
---
# セキュリティ義務 (Security Mandates)

すべてのコードは以下のセキュリティ基準を満たすこと。

## 禁止事項 (MUST NOT)

### シークレット管理
- APIキー、パスワード、トークンをコード内にハードコードしてはならない
- `.env` ファイルをGitにコミットしてはならない
- ログにセンシティブな情報を出力してはならない

### 危険な関数
- `eval()` の使用禁止
- `Function()` コンストラクタの使用禁止
- `innerHTML` への未サニタイズ入力の代入禁止

### データベース
- SQLの文字列結合によるクエリ構築禁止
- 必ずパラメータ化クエリまたはORMを使用すること

## 必須事項 (MUST)

### 入力検証
- すべてのユーザー入力をバリデーションすること
- 許可リスト方式でバリデーションすること（拒否リストではなく）

### 出力エンコーディング
- HTMLに出力する際は適切にエスケープすること
- JSONレスポンスは `Content-Type: application/json` を設定すること

### 認証・認可
- 認証が必要なエンドポイントには必ず認証ミドルウェアを適用すること
- 認可チェックは各リクエストで実行すること

### 依存関係
- 既知の脆弱性がある依存関係を使用しないこと
- 定期的に `npm audit` / `pnpm audit` を実行すること

## 環境変数の使用
```typescript
// ✅ 正しい例
const apiKey = process.env.API_KEY;

// ❌ 間違った例
const apiKey = "sk-1234567890abcdef";
```
```

`.agent/rules/stack.md`

**サイズ**: 959.0 B | **行数**: 42 行
```markdown
---
trigger: always_on
slug: tech-stack
---
# 技術スタック (Technology Stack)

このファイルはGA-Workspaceのテンプレートです。プロジェクトに合わせてカスタマイズしてください。

## ランタイム
- **Node.js**: Latest LTS (v20+)

## パッケージマネージャー
- **pnpm**: 推奨
- 代替: npm, yarn

## 言語
- **TypeScript**: メインの開発言語
- **JavaScript**: ES Modules形式

## フレームワーク/ライブラリ
（プロジェクトに合わせて記載）
- React
- Next.js
- Express
- etc.

## テスト
- **Vitest** または **Jest**: 単体テスト
- **Testing Library**: コンポーネントテスト
- **Playwright**: E2Eテスト

## Lint/Format
- **ESLint**: コード品質
- **Prettier**: コードフォーマット

## ビルドコマンド
```bash
pnpm build    # ビルド
pnpm dev      # 開発サーバー
pnpm test     # テスト実行
pnpm lint     # Lint実行
```
```

`.agent/rules/testing-standards.md`

**サイズ**: 1010.0 B | **行数**: 27 行
```markdown
---
trigger: model_decision
description: テストの作成、テスト戦略、テストカバレッジについて言及された場合に適用する。
slug: testing-standards
---
# テスト基準 (Testing Standards)

## テストの種類と範囲
- **単体テスト**: 個々の関数・メソッドの動作を検証
- **統合テスト**: モジュール間の連携を検証
- **E2Eテスト**: ユーザーシナリオ全体を検証

## 命名規則
テスト関数名は以下の形式に従うこと：
```
test_<対象機能>_<条件>_<期待結果>
```
例: `test_login_invalidPassword_returnsError`

## カバレッジ目標
- 新規コード: 80%以上のカバレッジを目指す
- クリティカルパス: 100%のカバレッジを維持する

## テストの独立性
- 各テストは他のテストに依存せず、単独で実行可能であること
- テストデータはテスト内で生成・クリーンアップすること
- 外部サービスはモック化すること
```

`.agent/rules/type-safety.md`

**サイズ**: 2.2 KB | **行数**: 84 行
```markdown
---
trigger: always_on
slug: type-safety
description: TypeScriptコードにおける型定義の厳格な基準を強制する。
---
# 型安全性基準 (Type Safety Standards)

このプロジェクトで生成または修正されるすべてのTypeScriptコードは、以下の基準を満たすこと。

## 必須事項 (MUST)

### 1. 完全な型アノテーション
すべての関数シグネチャに型注釈を付与すること。

```typescript
// ✅ 正しい例
function calculateTotal(items: Item[], taxRate: number): number {
  return items.reduce((sum, item) => sum + item.price, 0) * (1 + taxRate);
}

// ❌ 間違った例
function calculateTotal(items, taxRate) {
  return items.reduce((sum, item) => sum + item.price, 0) * (1 + taxRate);
}
```

### 2. any型の禁止
`any` 型の使用は原則禁止。代わりに `unknown` を使用し、型ガードで絞り込むこと。

```typescript
// ✅ 正しい例
function processData(data: unknown): string {
  if (typeof data === 'string') {
    return data.toUpperCase();
  }
  throw new Error('Expected string');
}

// ❌ 間違った例
function processData(data: any): string {
  return data.toUpperCase();
}
```

### 3. Strict Mode
`tsconfig.json` で以下を設定すること：

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noImplicitReturns": true
  }
}
```

### 4. Non-null Assertion の制限
`!` 演算子（Non-null Assertion）の使用は避け、適切なnullチェックを行うこと。

```typescript
// ✅ 正しい例
const element = document.getElementById('app');
if (element) {
  element.textContent = 'Hello';
}

// ❌ 避けるべき例
const element = document.getElementById('app')!;
element.textContent = 'Hello';
```

## 推奨事項 (SHOULD)

### 型エイリアスとインターフェース
- オブジェクトの形状定義には `interface` を使用
- ユニオン型や複雑な型には `type` を使用

### ジェネリクスの活用
再利用可能なコンポーネントや関数にはジェネリクスを活用すること。

### 型のエクスポート
他のモジュールから使用される型は明示的にエクスポートすること。
```

`.agent/rules/workflow-templates.md`

**サイズ**: 5.9 KB | **行数**: 249 行
```markdown
---
trigger: manual
description: 新しいワークフローを作成する際のテンプレート集。@workflow-templates で呼び出し可能。
slug: workflow-templates
---
# ワークフローテンプレート集 (Workflow Templates)

新しいワークフローを作成する際のテンプレート。コピーして使用すること。

---

## Template 1: 基本構造

```markdown
---
description: <このワークフローの目的を1-2文で説明>
---
# <ワークフロー名>

## Step 1: <準備/分析>
<前提条件の確認や情報収集>

## Step 2: <計画/設計>
<方針の策定、ユーザーへの確認>

## Step 3: <実行>
<主要なアクションの実行>

## Step 4: <検証> // turbo
<結果の確認、テスト実行>

## Step 5: <完了報告>
<結果のサマリーをユーザーに提示>
```

---

## Template 2: コード生成系

```markdown
---
description: 指定された仕様に基づいて<対象>を自動生成する。
---
# <対象>生成

## Step 1: 仕様の確認
ユーザーから以下を確認せよ：
- 生成対象の名前
- 必要な機能/フィールド
- 依存関係

## Step 2: 既存コードの分析 // turbo
関連する既存コードを分析し、パターンを把握せよ。

## Step 3: 設計の提示
生成するコードの設計案をユーザーに提示せよ：
- ファイル構造
- 主要な関数/クラス
- 型定義

## Step 4: コード生成
承認された設計に基づいてコードを生成せよ。

## Step 5: テスト生成
生成したコードに対するテストを作成せよ。

## Step 6: 検証 // turbo
テストを実行し、生成したコードが正しく動作することを確認せよ。
```

---

## Template 3: 修正/更新系

```markdown
---
description: <対象>を分析し、問題を特定して修正する。
---
# <対象>の修正

## Step 1: 問題の特定
以下を確認せよ：
- エラーメッセージ/症状
- 再現手順
- 発生条件

## Step 2: 原因調査 // turbo
関連するコードを分析し、根本原因を特定せよ。

## Step 3: 影響範囲の確認
修正が影響を与える可能性のある箇所を洗い出せ。

## Step 4: 修正案の提示
修正方針をユーザーに提示し、承認を得よ。

## Step 5: 修正の実施
承認された方針に基づいて修正を実施せよ。

## Step 6: リグレッションテスト // turbo
すべてのテストを実行し、リグレッションがないことを確認せよ。

## Step 7: 修正の報告
修正内容と確認結果をユーザーに報告せよ。
```

---

## Template 4: デプロイ/リリース系

```markdown
---
description: <環境>へのデプロイを安全に実行する。
---
# <環境>デプロイ

## Step 1: 事前チェック // turbo
以下を確認せよ：
- 未コミットの変更がないこと
- 正しいブランチにいること

## Step 2: ビルド検証 // turbo
プロダクションビルドが成功することを確認せよ。

## Step 3: テスト実行 // turbo
すべてのテストが通過することを確認せよ。

## Step 4: 環境変数の確認
必要な環境変数が設定されているか確認せよ。

## Step 5: デプロイ実行
**ユーザーの承認を得てから** デプロイを実行せよ。
（turboを付けないこと）

## Step 6: 動作確認
デプロイ後の動作確認を行え：
- ヘルスチェック
- 主要機能のスモークテスト

## Step 7: 完了報告
デプロイ結果を報告せよ。
```

---

## Template 5: 分析/レポート系

```markdown
---
description: <対象>を分析し、レポートを生成する。
---
# <対象>分析

## Step 1: データ収集 // turbo
分析に必要なデータを収集せよ。

## Step 2: 分析実行
収集したデータを分析せよ：
- <分析観点1>
- <分析観点2>
- <分析観点3>

## Step 3: 結果の整理
分析結果を以下の形式で整理せよ：

### サマリー
- 主要な発見事項

### 詳細
- 各観点の詳細な結果

### 推奨アクション
- 結果に基づく推奨事項

## Step 4: レポート生成
整理した結果をMarkdownレポートとして出力せよ。

## Step 5: 報告
レポートをユーザーに提示せよ。
```

---

## Template 6: 再帰的ワークフロー（他ワークフローを呼び出す）

```markdown
---
description: 複数のワークフローを順次実行し、総合的な処理を行う。
---
# 総合チェック

## Step 1: コード品質チェック
以下のワークフローを実行せよ：
- コマンド: `/lint-check`

## Step 2: テスト実行
以下のワークフローを実行せよ：
- コマンド: `/run-tests`

## Step 3: セキュリティチェック
以下のワークフローを実行せよ：
- コマンド: `/security-scan`

## Step 4: 結果の集約
各ワークフローの結果を集約し、総合レポートを作成せよ。

## Step 5: 報告
総合結果をユーザーに報告せよ：
- [ ] Lint: <結果>
- [ ] テスト: <結果>
- [ ] セキュリティ: <結果>
```

---

## Template 7: ブラウザ操作を含むワークフロー

```markdown
---
description: ブラウザを使用してUIの動作を検証する。
---
# UI検証

## Step 1: 開発サーバー起動 // turbo
開発サーバーを起動せよ：
\`\`\`bash
pnpm dev
\`\`\`

## Step 2: ブラウザでアクセス
ブラウザサブエージェントを使用して以下にアクセスせよ：
- URL: http://localhost:3000

## Step 3: 操作の実行
以下の操作を実行せよ：
1. <要素> をクリック
2. <フォーム> に <値> を入力
3. <ボタン> をクリック

## Step 4: 検証
以下を確認せよ：
- 期待される画面が表示されているか
- エラーメッセージが出ていないか
- コンソールエラーがないか

スクリーンショットを撮影して記録せよ。

## Step 5: 結果報告
検証結果をユーザーに報告せよ。
```
```

`.agent/workflows/auto-generate-agent-config.md`

**サイズ**: 5.5 KB | **行数**: 168 行
```markdown
---
description: プロジェクトの構造とコードを分析し、最適なルールとワークフローのセットを自動生成する。
---
# エージェント設定の自動生成 (Auto Generate Agent Config)

## Step 1: プロジェクト構造の分析 // turbo
プロジェクトのルートディレクトリを分析せよ：

```bash
# ディレクトリ構造を取得
find . -type f -name "*.json" -o -name "*.yaml" -o -name "*.yml" -o -name "*.toml" | head -20

# package.json または pyproject.toml を確認
cat package.json 2>/dev/null || cat pyproject.toml 2>/dev/null
```

以下を特定せよ：
- プログラミング言語（TypeScript, Python, Go など）
- パッケージマネージャー（npm, pnpm, yarn, pip, poetry など）
- フレームワーク（React, Next.js, FastAPI, Express など）
- 主要な依存関係

## Step 2: 既存設定ファイルの分析 // turbo
プロジェクトの既存設定を確認せよ：

- `tsconfig.json` → TypeScript設定
- `.eslintrc.*` → Lint設定
- `.prettierrc` → フォーマット設定
- `jest.config.*` / `vitest.config.*` → テスト設定
- `Dockerfile` / `docker-compose.yml` → コンテナ設定
- `.github/workflows/` → CI/CD設定

## Step 3: コードパターンの分析 // turbo
既存コードのパターンを分析せよ：

```bash
# ファイル拡張子の分布
find . -type f -name "*.ts" -o -name "*.tsx" -o -name "*.py" -o -name "*.go" | wc -l

# テストファイルの存在確認
find . -type f -name "*.test.*" -o -name "*.spec.*" -o -name "test_*" | head -10
```

以下を確認せよ：
- コーディングスタイル（インデント、命名規則）
- テストの有無とフレームワーク
- ディレクトリ構造のパターン

## Step 4: 推奨ルールの決定
分析結果に基づき、必要なルールを決定せよ：

### 必須ルール（always_on）
| 条件 | 作成するルール |
|------|----------------|
| 常に | `stack.md` - 技術スタック定義 |
| 常に | `security-mandates.md` - セキュリティ基準 |
| TypeScript使用 | `type-safety.md` - 型安全性基準 |
| React使用 | `react-components.md` - Reactコンポーネント規約 |

### 状況依存ルール（model_decision）
| 条件 | 作成するルール |
|------|----------------|
| 常に | `ops.md` - 運用手順 |
| 常に | `refactoring.md` - リファクタリング基準 |
| API開発 | `api-design.md` - API設計基準 |
| DB使用 | `database.md` - データベース規約 |

## Step 5: 推奨ワークフローの決定
プロジェクトの特性に基づき、必要なワークフローを決定せよ：

### 基本ワークフロー（全プロジェクト共通）
- `generate-unit-tests.md` - 単体テスト生成
- `create-feature.md` - 機能追加
- `bug-fix.md` - バグ修正
- `code-review.md` - コードレビュー

### 追加ワークフロー（条件付き）
| 条件 | 作成するワークフロー |
|------|----------------------|
| Webアプリ | `ui-verification.md` - UI検証 |
| API開発 | `generate-api-docs.md` - APIドキュメント生成 |
| CI/CD設定あり | `deploy-staging.md` - ステージングデプロイ |
| Dockerあり | `docker-build.md` - Dockerビルド |

## Step 6: 設定案の提示
分析結果と推奨設定をユーザーに提示せよ：

```
## プロジェクト分析結果

### 検出された技術スタック
- 言語: <検出結果>
- フレームワーク: <検出結果>
- パッケージマネージャー: <検出結果>

### 推奨ルール（<N>個）
1. stack.md (always_on) - 技術スタック定義
2. security-mandates.md (always_on) - セキュリティ基準
...

### 推奨ワークフロー（<M>個）
1. generate-unit-tests.md - 単体テスト生成
2. create-feature.md - 機能追加
...

これらの設定を作成しますか？
```

ユーザーの承認を得よ。カスタマイズの要望があれば反映せよ。

## Step 7: .agent ディレクトリの作成 // turbo
エージェント設定用のディレクトリ構造を作成せよ：

```bash
mkdir -p .agent/rules .agent/workflows
```

## Step 8: ルールファイルの生成
承認されたルールファイルを生成せよ。

各ルールは以下を含むこと：
- 適切なYAMLフロントマター
- プロジェクト固有の設定値
- 具体的な制約事項

## Step 9: ワークフローファイルの生成
承認されたワークフローファイルを生成せよ。

各ワークフローは以下を含むこと：
- プロジェクトで使用するコマンド
- 適切なTurboアノテーション
- エラーハンドリング

## Step 10: 検証 // turbo
生成した設定の検証を行え：

```bash
# 作成されたファイルの確認
ls -la .agent/rules/
ls -la .agent/workflows/

# YAMLフロントマターの構文チェック（簡易）
head -10 .agent/rules/*.md
```

## Step 11: 完了報告
以下をユーザーに報告せよ：

### 作成されたファイル一覧
```
.agent/
├── rules/
│   ├── stack.md
│   ├── security-mandates.md
│   └── ...
└── workflows/
    ├── generate-unit-tests.md
    ├── create-feature.md
    └── ...
```

### 使用方法
- ルール: 自動的に適用される（トリガー条件に基づく）
- ワークフロー: `/<ワークフロー名>` で呼び出し

### 次のステップの提案
- 追加で必要なルール/ワークフローがあれば `/create-rule` または `/create-workflow` を使用
- 既存の設定をカスタマイズする場合は直接ファイルを編集
```

`.agent/workflows/bug-fix.md`

**サイズ**: 2.3 KB | **行数**: 74 行
```markdown
---
description: バグの調査、原因特定、修正、検証までを体系的に行う。
---
# バグ修正 (Bug Fix)

**再帰的合成**: このワークフローは他のワークフローを呼び出して構成される。

```
/bug-fix
├── 調査・修正（このワークフロー固有）
├── /generate-unit-tests（リグレッションテスト追加）
└── /verify-code（コード検証）
```

---

## Step 1: 問題の再現
報告されたバグを再現せよ：
- 再現手順を確認・実行
- エラーメッセージやログを収集
- 発生条件（環境、入力値等）を特定

## Step 2: 原因調査
バグの根本原因を特定せよ：
- スタックトレースの分析
- 関連するコードのレビュー
- 変更履歴（git blame）の確認
- デバッグログの挿入（必要に応じて）

## Step 3: 影響範囲の特定
修正が影響を与える可能性のある箇所を洗い出せ：
- 同じ関数を呼び出している他のコード
- 関連するテストケース
- 依存するモジュール

## Step 4: ブランチ作成 // turbo
修正用のブランチを作成せよ：
```bash
git checkout -b fix/<issue-number>-<short-description>
```

## Step 5: 修正実装
バグを修正せよ。以下に注意すること：
- 最小限の変更で修正する
- 新たなバグを混入させない
- 型安全性を維持する（`@type-safety` 参照）

## Step 6: リグレッションテスト作成
このバグを検知するテストケースを追加せよ：
- コマンド: `/generate-unit-tests`（対象ファイル指定）
- 修正前の状態でテストが失敗することを確認
- 修正後にテストが成功することを確認

## Step 7: コード検証
コードの健全性を検証せよ：
- コマンド: `/verify-code`
- 失敗時: 問題箇所を修正してから再実行

## Step 8: コミット
修正をコミットせよ：
```bash
git add .
git commit -m "fix(<scope>): <バグの簡潔な説明>

- 原因: <根本原因の説明>
- 対応: <修正内容の説明>
- Closes #<issue-number>"
```

## Step 9: 完了報告
以下を報告せよ：
- 原因と修正内容の要約
- 追加したテストケース
- 検証結果サマリー（`/verify-code` の結果）
```

`.agent/workflows/code-review.md`

**サイズ**: 1.9 KB | **行数**: 61 行
```markdown
---
description: PRやコード変更に対して体系的なレビューを実施する。
---
# コードレビュー (Code Review)

## Step 1: 変更内容の把握
レビュー対象の変更を確認せよ：
- 変更されたファイルの一覧を取得
- 各ファイルのdiffを確認
- コミットメッセージを読み、意図を理解

## Step 2: アーキテクチャレビュー
設計レベルの問題がないか確認せよ：
- 既存のアーキテクチャと整合性があるか
- 適切なレイヤー分離がされているか
- 過度な複雑性が導入されていないか

## Step 3: コード品質チェック
以下の観点でコードをレビューせよ：

### 可読性
- 変数名・関数名は意図を明確に表しているか
- ロジックは理解しやすいか
- 適切なコメントがあるか

### 保守性
- DRY原則に従っているか
- 単一責任原則を満たしているか
- テスト可能な設計か

### 型安全性
- すべての関数に型注釈があるか
- `any` 型が使用されていないか
- Null安全性が確保されているか

## Step 4: セキュリティチェック
セキュリティ上の問題がないか確認せよ：
- シークレットがハードコードされていないか
- ユーザー入力が適切にサニタイズされているか
- SQLインジェクション等の脆弱性がないか

## Step 5: テストの確認
テストが十分か確認せよ：
- 新規コードに対するテストがあるか
- エッジケースがカバーされているか
- テストが正しく動作するか

## Step 6: レビュー結果の報告
レビュー結果を以下の形式で報告せよ：

### 必須修正 (Must Fix)
- 重大な問題点

### 推奨修正 (Should Fix)
- 改善が望ましい点

### 提案 (Suggestion)
- 参考程度の提案

### 良かった点 (Good Points)
- 優れている部分
```

`.agent/workflows/create-feature.md`

**サイズ**: 2.3 KB | **行数**: 71 行
```markdown
---
description: 新機能の設計から実装、テスト、ドキュメント作成までを体系的に行う。
---
# 新機能追加 (Create Feature)

**再帰的合成**: このワークフローは他のワークフローを呼び出して構成される。

```
/create-feature
├── 設計・実装（このワークフロー固有）
├── /generate-unit-tests（テスト生成）
└── /verify-code（コード検証）
```

---

## Step 1: 要件の確認
ユーザーから機能要件を聞き取り、以下を明確にせよ：
- 機能の目的とユースケース
- 入力と出力の仕様
- 既存コードへの影響範囲
- 非機能要件（パフォーマンス、セキュリティ等）

## Step 2: 設計の提案
実装方針をユーザーに提示せよ：
- 影響を受けるファイルの一覧
- 新規作成するファイルの一覧
- データ構造やインターフェースの設計
- 考慮すべきエッジケース

## Step 3: ブランチ作成 // turbo
機能用のブランチを作成せよ：
```bash
git checkout -b feature/<feature-name>
```

## Step 4: 実装
設計に基づいてコードを実装せよ。
以下のルールを遵守すること：
- 型安全性を確保する（`@type-safety` 参照）
- セキュリティ要件を満たす（`@security-mandates` 参照）
- 適切なエラーハンドリングを実装する

## Step 5: テスト作成
実装した機能に対する単体テストを作成せよ：
- コマンド: `/generate-unit-tests`
- 失敗時: エラー内容を報告し、手動でのテスト作成を提案

## Step 6: ドキュメント更新
以下のドキュメントを更新せよ：
- 関数・クラスのTSDoc/JSDoc
- READMEの該当セクション（必要に応じて）
- CHANGELOG.md

## Step 7: コード検証
コードの健全性を検証せよ：
- コマンド: `/verify-code`
- 失敗時: 問題箇所を修正してから再実行

## Step 8: コミット
変更を論理的な単位でコミットせよ（Conventional Commits形式）：
```bash
git add .
git commit -m "feat(<scope>): <description>"
```

## Step 9: 完了報告
以下を報告せよ：
- 作成/変更したファイル一覧
- 検証結果サマリー（`/verify-code` の結果）
- 次のステップ（PR作成など）
```

`.agent/workflows/create-rule.md`

**サイズ**: 3.3 KB | **行数**: 98 行
```markdown
---
description: ユーザーの要求から新しいルールファイル（.agent/rules/*.md）を対話的に作成する。
---
# ルール作成 (Create Rule)

## Step 1: 要求のヒアリング
ユーザーから以下の情報を収集せよ：

1. **何を制約したいか**: どのような行動・出力を制御したいか
2. **いつ適用するか**: 常に？特定の状況で？特定のファイルに対して？
3. **禁止事項はあるか**: 絶対にやってはいけないことは何か
4. **例外条件はあるか**: ルールを適用しないケースはあるか

情報が不足している場合は、具体的な質問で補完せよ。

## Step 2: トリガータイプの決定
収集した情報から最適なトリガーを判断せよ：

| ユーザーの意図 | 推奨トリガー |
|----------------|--------------|
| 「プロジェクト全体で常に〜」 | `always_on` |
| 「〜するときは」「〜の場合は」 | `model_decision` |
| 「〜ファイルに対しては」 | `glob` |
| 「明示的に指定したときだけ」 | `manual` |

選択したトリガーとその理由をユーザーに説明せよ。

## Step 3: ルール構造の設計
以下の構造でルールを設計せよ：

```markdown
---
trigger: <決定したトリガー>
description: <model_decisionの場合は意図を捉えるキーワードを含める>
slug: <ファイル名と同一>
---
# <ルール名>

## 基本方針
<ルールの目的と基本的な考え方>

## 必須事項 (MUST)
<必ず守るべきこと>

## 禁止事項 (MUST NOT)
<絶対にやってはいけないこと>

## 推奨事項 (SHOULD)
<できれば守るべきこと>

## 例外条件
<ルールを適用しないケース>
```

設計案をユーザーに提示し、フィードバックを求めよ。

## Step 4: ファイル名の決定
以下のルールに従ってファイル名を決定せよ：

- 形式: `<カテゴリ>-<具体的な内容>.md`
- ケバブケース（小文字、ハイフン区切り）
- 簡潔だが内容がわかる名前

例:
- `security-api-keys.md`
- `typescript-strict-mode.md`
- `react-hooks-usage.md`

## Step 5: 既存ルールとの整合性チェック
`.agent/rules/` 配下の既存ルールを確認せよ：

1. **重複チェック**: 同様の制約が既に存在しないか
2. **矛盾チェック**: 既存ルールと矛盾する内容がないか
3. **参照可能性**: 既存ルールを `@` 参照で再利用できないか

問題がある場合はユーザーに報告し、対処方針を相談せよ。

## Step 6: ルールファイルの生成
設計に基づいてルールファイルを作成せよ。

保存先: `.agent/rules/<決定したファイル名>`

## Step 7: 検証
作成したルールの検証を行え：

1. **YAML構文チェック**: フロントマターが正しくパースできるか
2. **内容の確認**: ユーザーの要求を満たしているか
3. **可読性**: 構造が明確で理解しやすいか

作成したルールの全文をユーザーに提示し、最終確認を求めよ。

## Step 8: 完了報告
以下の情報をユーザーに報告せよ：

- 作成したファイルのパス
- 選択したトリガータイプ
- ルールが適用される条件の説明
- 関連する既存ルール（あれば）
```

`.agent/workflows/create-workflow.md`

**サイズ**: 4.5 KB | **行数**: 126 行
```markdown
---
description: ユーザーの要求から新しいワークフローファイル（.agent/workflows/*.md）を対話的に作成する。
---
# ワークフロー作成 (Create Workflow)

## Step 1: タスクのヒアリング
ユーザーから以下の情報を収集せよ：

1. **何を達成したいか**: ワークフローのゴールは何か
2. **どんな手順で行うか**: 大まかなステップの流れ
3. **自動化したい部分**: エージェントに任せたい操作
4. **確認が必要な部分**: ユーザー承認が必要なポイント
5. **使用するツール**: ターミナルコマンド、ブラウザ操作など

情報が不足している場合は、具体的な質問で補完せよ。

## Step 2: ステップの分解
タスクを論理的なステップに分解せよ：

### 分解の基準
- **1ステップ = 1つの明確なアクション**
- **依存関係を考慮**: 前のステップの結果が必要か
- **並列実行可能か**: 独立したステップは並列化を検討

### ステップの種類
| 種類 | 内容 | 例 |
|------|------|-----|
| 分析 | 情報の収集・解析 | ファイル読み込み、コード解析 |
| 計画 | 方針の策定・提示 | テスト計画、リファクタリング案 |
| 実行 | 実際の操作 | コード生成、ファイル作成 |
| 検証 | 結果の確認 | テスト実行、動作確認 |
| 報告 | ユーザーへの通知 | 完了報告、エラー報告 |

分解したステップをユーザーに提示し、フィードバックを求めよ。

## Step 3: Turbo Mode の判定
各ステップについて `// turbo` の適用可否を判定せよ：

### Turbo適用可（ユーザー承認不要）
- 読み取り操作（`git status`, `ls`, `cat`）
- テスト実行（`pnpm test`, `pytest`）
- Lint/型チェック（`pnpm lint`, `tsc --noEmit`）
- ビルド（`pnpm build`）

### Turbo適用不可（ユーザー承認必要）
- ファイル削除
- Git push / merge / rebase
- デプロイ操作
- 外部APIへの書き込み
- 課金が発生する操作

判定結果をユーザーに提示し、調整が必要か確認せよ。

## Step 4: エラーハンドリングの設計
各ステップで起こりうるエラーと対処法を設計せよ：

```
ステップ: <ステップ名>
想定エラー:
  - <エラー1>: <対処法>
  - <エラー2>: <対処法>
最大リトライ: <回数>
リトライ後も失敗: <中断 or ユーザーに報告>
```

## Step 5: ワークフロー構造の設計
以下の構造でワークフローを設計せよ：

```markdown
---
description: <ワークフローの目的を簡潔に>
---
# <ワークフロー名>

## Step 1: <ステップ名>
<具体的な指示>

## Step 2: <ステップ名> // turbo
<具体的な指示>

**エラー時**: <対処法>
```

設計案をユーザーに提示し、フィードバックを求めよ。

## Step 6: ファイル名の決定
以下のルールに従ってファイル名を決定せよ：

- 形式: `<動詞>-<対象>.md`
- ケバブケース（小文字、ハイフン区切り）
- コマンドとして呼びやすい名前

例:
- `generate-api-docs.md` → `/generate-api-docs`
- `setup-database.md` → `/setup-database`
- `deploy-production.md` → `/deploy-production`

## Step 7: 既存ワークフローとの整合性チェック
`.agent/workflows/` 配下の既存ワークフローを確認せよ：

1. **重複チェック**: 同様の機能が既に存在しないか
2. **再利用可能性**: 既存ワークフローを呼び出して使えないか
3. **命名の一貫性**: 既存の命名規則と整合しているか

## Step 8: ワークフローファイルの生成
設計に基づいてワークフローファイルを作成せよ。

保存先: `.agent/workflows/<決定したファイル名>`

## Step 9: 検証
作成したワークフローの検証を行え：

1. **YAML構文チェック**: フロントマターが正しくパースできるか
2. **ステップの論理性**: 順序や依存関係が正しいか
3. **指示の明確さ**: エージェントが迷わず実行できるか
4. **Turboの適切さ**: 危険な操作にTurboが付いていないか

作成したワークフローの全文をユーザーに提示し、最終確認を求めよ。

## Step 10: 完了報告
以下の情報をユーザーに報告せよ：

- 作成したファイルのパス
- 呼び出しコマンド（`/<ファイル名>`）
- ワークフローの概要フロー図（テキスト形式）
- 関連するルールやワークフロー（あれば）
```

`.agent/workflows/deploy-staging.md`

**サイズ**: 2.0 KB | **行数**: 68 行
```markdown
---
description: ステージング環境へのデプロイを安全に実行する。
---
# ステージングデプロイ (Deploy Staging)

**再帰的合成**: このワークフローは他のワークフローを呼び出して構成される。

```
/deploy-staging
├── /verify-code（事前検証）
├── ビルド・デプロイ（このワークフロー固有）
└── 動作確認
```

---

## Step 1: 事前チェック // turbo
デプロイ前の確認を行え：
```bash
# 現在のブランチを確認
git branch --show-current

# 未コミットの変更がないか確認
git status
```

## Step 2: コード検証
コードの健全性を事前検証せよ：
- コマンド: `/verify-code`
- 失敗時: デプロイを中止し、問題を報告

## Step 3: ビルド検証 // turbo
プロダクションビルドが成功することを確認せよ：
```bash
pnpm build
```
ビルドエラーがある場合は、修正してから続行すること。

## Step 4: 環境変数の確認
ステージング環境に必要な環境変数が設定されているか確認せよ：
- 必須の環境変数一覧をユーザーに提示
- 不足している場合は警告

## Step 5: デプロイ実行
ユーザーの承認を得てからデプロイを実行せよ。
（自動実行しないこと - 本番に影響する可能性があるため）

## Step 6: 動作確認
デプロイ後の動作確認手順を提示せよ：
- ヘルスチェックエンドポイントの確認
- 主要機能の簡易テスト
- ログの監視ポイント

## Step 7: ロールバック手順の提示
問題発生時のロールバック手順を提示せよ：
```bash
# 直前のデプロイに戻す
git revert HEAD
# または特定のコミットに戻す
git checkout <commit-hash>
```

## Step 8: 完了報告
デプロイ結果をユーザーに報告せよ：
- デプロイ時刻
- デプロイされたコミットハッシュ
- ステージング環境のURL
- ロールバック方法
```

`.agent/workflows/generate-readme.md`

**サイズ**: 1.6 KB | **行数**: 59 行
```markdown
---
description: プロジェクトの構造を分析し、READMEを自動生成または更新する。
---
# README生成 (Generate README)

## Step 1: プロジェクト分析
プロジェクトの構造を分析せよ：
- ディレクトリ構造の把握
- package.json / pyproject.toml 等の設定ファイルを読み込み
- 使用している技術スタックの特定
- エントリーポイントの特定

## Step 2: 既存READMEの確認
既存のREADME.mdがあるか確認せよ：
- ある場合: 内容を分析し、不足セクションを特定
- ない場合: 新規作成モードで続行

## Step 3: コンテンツ生成
以下のセクションを生成せよ：

### プロジェクト名とバッジ
- プロジェクト名
- ライセンスバッジ
- ビルドステータスバッジ（CI設定がある場合）

### 概要
- プロジェクトの目的（1-2文）
- 主な機能（箇条書き3-5項目）

### 前提条件
- 必要なランタイム/ツール
- バージョン要件

### インストール
- クローン手順
- 依存関係のインストール
- 環境変数の設定

### 使用方法
- 起動コマンド
- 基本的な使い方の例

### 開発
- 開発サーバーの起動方法
- テストの実行方法
- ビルド方法

### ディレクトリ構造
- 主要なディレクトリの説明

### ライセンス
- ライセンス情報

## Step 4: レビューと調整
生成したREADMEをユーザーに提示し、フィードバックを求めよ。
必要に応じて内容を調整すること。

## Step 5: ファイル保存
最終的なREADME.mdをプロジェクトルートに保存せよ。
```

`.agent/workflows/generate-unit-tests.md`

**サイズ**: 1.6 KB | **行数**: 38 行
```markdown
---
description: 指定されたファイルに対して単体テストを自動生成し、実行・検証まで行う。
---
# 単体テスト生成 (Generate Unit Tests)

## Step 1: コンテキスト分析
対象ファイルを読み込み、以下を特定せよ：
- すべてのパブリック関数とクラス
- 各関数の入力パラメータと戻り値の型
- 依存関係（外部モジュール、API呼び出し等）
- 想定されるエッジケース（境界値、null/undefined、例外）

## Step 2: テスト計画の作成
分析結果に基づき、テストケースのリストを作成してユーザーに提示せよ。
各テストケースには以下を含めること：
- テスト対象の関数名
- テストシナリオの説明
- 期待される結果

## Step 3: モック戦略の決定
外部依存関係に対するモック化の方針を決定せよ：
- データベース接続 → モック化必須
- 外部API呼び出し → モック化必須
- ファイルシステム操作 → 状況に応じてモック化

## Step 4: テストコード生成
`tests/` または `__tests__/` ディレクトリに適切なテストファイルを作成せよ。
命名規則: `<filename>.test.ts` または `test_<filename>.py`

## Step 5: 実行と検証 // turbo
テストを実行せよ（`pnpm test` または `pytest`）。
失敗したテストがある場合：
1. エラーログを分析
2. テストコードまたは実装コードを修正
3. 最大3回まで再実行

## Step 6: カバレッジレポート
テストカバレッジを確認し、結果をユーザーに報告せよ。
```

`.agent/workflows/health-check.md`

**サイズ**: 3.3 KB | **行数**: 122 行
```markdown
---
description: GA-Workspaceの設定が正しく構成されているか健全性をチェックする。
---
# 健全性チェック (Health Check)

**目的**: GA-Workspaceの運用性と可用性を維持するための定期チェック。

---

## Step 1: 構造チェック // turbo
必須ディレクトリとファイルの存在を確認せよ：

```bash
echo "=== ディレクトリ構造 ==="
ls -la .agent/rules/ 2>/dev/null || echo "❌ rules/ not found"
ls -la .agent/workflows/ 2>/dev/null || echo "❌ workflows/ not found"
```

### 必須ファイルチェック
| ファイル | 状態 |
|----------|------|
| `.agent/rules/ga-workspace-definition.md` | ✅/❌ |
| `.agent/rules/stack.md` | ✅/❌ |
| `.agent/rules/security-mandates.md` | ✅/❌ |
| `.agent/workflows/create-rule.md` | ✅/❌ |
| `.agent/workflows/create-workflow.md` | ✅/❌ |

## Step 2: YAML構文チェック // turbo
各ルール・ワークフローのフロントマターが正しいか検証せよ：

```bash
for f in .agent/rules/*.md .agent/workflows/*.md; do
  head -20 "$f" | grep -E "^(trigger|description|slug):" || echo "⚠️ $f: missing frontmatter"
done
```

### チェック項目
- `---` で囲まれたフロントマターが存在するか
- ルール: `trigger` フィールドが存在するか
- ワークフロー: `description` フィールドが存在するか

## Step 3: 参照整合性チェック
`@path/to/file.md` 形式の参照が解決可能か確認せよ：

```bash
grep -r "@.*\.md" .agent/ | while read line; do
  ref=$(echo "$line" | grep -oE "@[^ ]+\.md")
  # 参照先が存在するか確認
done
```

## Step 4: 重複・矛盾チェック
以下を検出せよ：

### 重複チェック
- 同じ `slug` を持つルールが複数存在しないか
- 同じ名前のワークフローが存在しないか

### 矛盾チェック
- `always_on` ルール間で相反する指示がないか
- 例: 「タブを使え」と「スペースを使え」

## Step 5: 依存関係チェック
ワークフロー間の呼び出し関係を検証せよ：

```
/verify-code
├── /lint-check ✅ 存在
├── /type-check ✅ 存在
└── /run-tests ✅ 存在
```

呼び出し先が存在しない場合は警告を出力。

## Step 6: 循環参照チェック
ワークフローの循環呼び出しがないか確認せよ：

```
❌ 循環検出: /a → /b → /c → /a
```

## Step 7: 結果レポート
健全性チェックの結果を報告せよ：

```
## GA-Workspace 健全性レポート 🏥

チェック日時: <timestamp>

### 構造 
- ディレクトリ: ✅ OK
- 必須ファイル: ✅ 5/5

### 構文
- ルール: ✅ <N>ファイル OK
- ワークフロー: ✅ <M>ファイル OK

### 整合性
- 参照解決: ✅ OK
- 重複: ✅ なし
- 矛盾: ⚠️ 1件の警告

### 依存関係
- 未解決の呼び出し: ✅ なし
- 循環参照: ✅ なし

---
**総合判定**: ✅ HEALTHY / ⚠️ WARNINGS (<N>件) / ❌ UNHEALTHY
```

## Step 8: 修復提案（問題検出時）
問題が検出された場合、修復手順を提案せよ：

```
### 検出された問題と修復手順

1. **❌ stack.md が存在しない**
   → `/create-rule` を実行して作成

2. **⚠️ /deploy-staging が存在しない呼び出しを含む**
   → 呼び出し先を作成するか、参照を修正
```
```

`.agent/workflows/lint-check.md`

**サイズ**: 646.0 B | **行数**: 21 行
```markdown
---
description: コードスタイルのLintチェックを実行する原子ワークフロー。
---
# Lintチェック (Lint Check)

## 実行 // turbo
Lintを実行せよ：
```bash
pnpm lint || npm run lint || yarn lint
```

## 結果判定
- **成功**: Lintエラーなし → `PASS` を返す
- **警告のみ**: 警告はあるがエラーなし → `PASS_WITH_WARNINGS` を返す
- **失敗**: エラーあり → `FAIL` を返す

## エラー時の出力
失敗した場合、以下を報告せよ：
- エラー数と警告数
- 主要なエラー内容（最大5件）
- 自動修正可能かどうか（`--fix` オプション）
```

`.agent/workflows/manage-agent-config.md`

**サイズ**: 2.7 KB | **行数**: 79 行
```markdown
---
description: 現在のプロジェクトに設定されているルールとワークフローの一覧を表示し、管理操作を行う。
---
# エージェント設定の管理 (Manage Agent Config)

## Step 1: 設定ディレクトリの確認 // turbo
`.agent` ディレクトリの存在と構造を確認せよ：

```bash
if [ -d ".agent" ]; then
  echo "=== Rules ==="
  ls -la .agent/rules/ 2>/dev/null || echo "No rules directory"
  echo ""
  echo "=== Workflows ==="
  ls -la .agent/workflows/ 2>/dev/null || echo "No workflows directory"
else
  echo ".agent directory not found"
fi
```

## Step 2: ルール一覧の表示
各ルールファイルのメタ情報を抽出して表示せよ：

| ファイル名 | トリガー | 説明 |
|------------|----------|------|
| `<name>.md` | `<trigger>` | `<description>` |

### トリガー別の分類
- **always_on**: 常に適用されるルール
- **model_decision**: 意図に基づいて適用されるルール
- **glob**: ファイルパターンで適用されるルール
- **manual**: 手動で呼び出すルール

## Step 3: ワークフロー一覧の表示
各ワークフローファイルのメタ情報を抽出して表示せよ：

| コマンド | 説明 |
|----------|------|
| `/<name>` | `<description>` |

## Step 4: 操作の選択
ユーザーに以下の操作を提示せよ：

1. **詳細表示**: 特定のルール/ワークフローの内容を表示
2. **新規作成**: `/create-rule` または `/create-workflow` を呼び出し
3. **編集**: 既存ファイルの修正
4. **削除**: 不要なファイルの削除
5. **検証**: 設定の整合性チェック
6. **終了**: 操作を終了

ユーザーの選択に応じて処理を分岐せよ。

## Step 5: 詳細表示（選択時）
指定されたファイルの全内容を表示せよ。

## Step 6: 編集（選択時）
ユーザーから編集内容を聞き取り、ファイルを更新せよ。
変更前と変更後のdiffを表示し、確認を求めること。

## Step 7: 削除（選択時）
削除対象のファイルを確認し、ユーザーの最終承認を得てから削除せよ。

```bash
rm .agent/rules/<target>.md
# または
rm .agent/workflows/<target>.md
```

## Step 8: 検証（選択時）
設定の整合性チェックを行え：

### チェック項目
1. **YAML構文**: フロントマターが正しくパースできるか
2. **必須フィールド**: trigger/description が存在するか
3. **参照の解決**: `@path/to/file.md` の参照先が存在するか
4. **重複チェック**: 同じslugが複数存在しないか
5. **矛盾チェック**: 相反するルールが存在しないか

問題がある場合は、ファイル名と問題点を報告せよ。
```

`.agent/workflows/performance-optimization.md`

**サイズ**: 1.8 KB | **行数**: 62 行
```markdown
---
description: コードのパフォーマンス分析と最適化を体系的に行う。
---
# パフォーマンス最適化 (Performance Optimization)

## Step 1: ボトルネックの特定
パフォーマンス問題の箇所を特定せよ：
- ユーザーから報告された遅い処理
- プロファイリング結果の分析
- 計算量が高いアルゴリズムの検出

## Step 2: 現状の計測
最適化前のベースラインを計測せよ：
- 実行時間の計測
- メモリ使用量の確認
- CPU使用率の確認
- N+1クエリの検出（DB操作がある場合）

## Step 3: 最適化戦略の立案
以下の観点から最適化案を提示せよ：

### アルゴリズムの改善
- 計算量の削減（O(n²) → O(n log n) など）
- 不要なループの削除
- 早期リターンの活用

### データ構造の最適化
- 適切なデータ構造の選択（Map, Set等）
- キャッシュの導入
- 遅延評価の活用

### I/O最適化
- バッチ処理化
- 並列処理の導入
- 非同期処理の活用

### メモリ最適化
- 不要なオブジェクトの早期解放
- ストリーミング処理の導入
- 大きな配列のチャンク処理

## Step 4: 実装
最もインパクトの大きい最適化から順に実装せよ。
各最適化は個別のコミットとして記録すること。

## Step 5: 効果測定 // turbo
最適化後のパフォーマンスを計測せよ：
- 実行時間の比較
- メモリ使用量の比較
- 改善率の算出

## Step 6: リグレッションテスト // turbo
最適化によって機能が壊れていないことを確認せよ：
```bash
pnpm test
```

## Step 7: 結果報告
最適化結果をユーザーに報告せよ：
- 実施した最適化の内容
- パフォーマンス改善率
- トレードオフ（あれば）
```

`.agent/workflows/run-tests.md`

**サイズ**: 613.0 B | **行数**: 22 行
```markdown
---
description: 単体テストを実行する原子ワークフロー。
---
# テスト実行 (Run Tests)

## 実行 // turbo
テストを実行せよ：
```bash
pnpm test || npm test || yarn test || pytest
```

## 結果判定
- **成功**: 全テスト通過 → `PASS` を返す
- **失敗**: 失敗したテストあり → `FAIL` を返す
- **スキップ**: スキップされたテストあり → `PASS_WITH_SKIPPED` を返す

## 出力内容
以下を報告せよ：
- 実行したテスト数
- 成功/失敗/スキップの内訳
- 失敗したテスト名と理由（最大5件）
- 実行時間
```

`.agent/workflows/security-scan.md`

**サイズ**: 1.0 KB | **行数**: 31 行
```markdown
---
description: セキュリティ脆弱性のスキャンを実行する原子ワークフロー。
---
# セキュリティスキャン (Security Scan)

## Step 1: 依存関係の脆弱性チェック // turbo
```bash
pnpm audit || npm audit || yarn audit || pip-audit
```

## Step 2: シークレット検出 // turbo
コード内にハードコードされたシークレットがないか検出せよ：
- APIキーのパターン
- パスワードのパターン
- プライベートキーのパターン

## Step 3: セキュリティルール違反チェック
`security-mandates.md` に定義された禁止事項を検証せよ：
- `eval()` の使用
- SQLの文字列結合
- サニタイズなしのユーザー入力

## 結果判定
- **成功**: 問題なし → `PASS` を返す
- **警告**: 低リスクの問題あり → `PASS_WITH_WARNINGS` を返す
- **失敗**: 高リスクの問題あり → `FAIL` を返す

## 出力内容
以下を報告せよ：
- 検出された脆弱性の数（Critical/High/Medium/Low）
- 各問題の概要と対処法
```

`.agent/workflows/setup-ga-workspace.md`

**サイズ**: 3.6 KB | **行数**: 111 行
```markdown
---
description: 新規または既存プロジェクトにGA-Workspace構造を初期化する。GA-Workspaceを作るためのワークフロー。
---
# GA-Workspaceセットアップ (Setup GA-Workspace)

**メタ定義**: このワークフロー自体がGA-Workspaceの一部であり、新しいGA-Workspaceを生成する。

```
GA-Workspace (Meta) --[/setup-ga-workspace]--> GA-Workspace (New Project)
```

---

## Step 1: プロジェクト情報の収集
以下の情報を収集せよ：

1. **プロジェクト名**: ディレクトリ名またはユーザー指定
2. **プロジェクトパス**: 対象ディレクトリのパス
3. **技術スタック**: 言語、フレームワーク、パッケージマネージャー
4. **プロジェクトタイプ**: Web、API、CLI、ライブラリなど

既存の `package.json` や `pyproject.toml` があれば自動検出を試みよ。

## Step 2: 設定レベルの選択
ユーザーに設定レベルを選択させよ：

| レベル | 内容 |
|--------|------|
| **Minimal** | 必須ルール3つ + メタワークフロー2つ |
| **Standard** | Minimal + 推奨ルール + 基本ワークフロー |
| **Full** | Standard + 全テンプレート + 拡張ワークフロー |

## Step 3: ディレクトリ構造の作成 // turbo
GA-Workspace用のディレクトリを作成せよ：
```bash
mkdir -p .agent/rules .agent/workflows
```

## Step 4: 必須ルールの生成
以下の必須ルールを生成せよ：

### 4.1: ga-workspace-definition.md
GA-Workspaceの定義ルールをコピー（このメタワークスペースから）

### 4.2: stack.md
収集した技術スタック情報に基づいて生成：
- コマンド: `/create-rule` を内部呼び出し
- テンプレート: `@rule-templates` の Tech Stack セクション

### 4.3: security-mandates.md
セキュリティ基準ルールを生成：
- コマンド: `/create-rule` を内部呼び出し
- テンプレート: `@rule-templates` の Security セクション

## Step 5: メタワークフローの生成
ルール・ワークフロー作成用のメタワークフローを生成せよ：

### 5.1: create-rule.md
このメタワークスペースからコピー

### 5.2: create-workflow.md
このメタワークスペースからコピー

## Step 6: 追加コンポーネントの生成（Standard以上）
Standard/Fullレベルの場合、追加で生成：

### ルール
- `ops.md` - 運用手順
- `type-safety.md` - 型安全性（TypeScriptの場合）
- `project-governance.md` - ガバナンス

### ワークフロー
- `verify-code.md` - コード検証（合成）
- `lint-check.md` - Lintチェック（原子）
- `type-check.md` - 型チェック（原子）
- `run-tests.md` - テスト実行（原子）

## Step 7: テンプレートの配置（Fullのみ）
Fullレベルの場合、テンプレート集も配置：
- `rule-templates.md`
- `workflow-templates.md`

## Step 8: 検証
生成した設定の検証を行え：
- コマンド: `/health-check` を内部呼び出し

## Step 9: 完了報告
以下を報告せよ：

```
## GA-Workspace セットアップ完了 🚀

プロジェクト: <プロジェクト名>
レベル: <Minimal/Standard/Full>

### 作成されたファイル
.agent/
├── rules/
│   ├── ga-workspace-definition.md ✅
│   ├── stack.md ✅
│   └── ...
└── workflows/
    ├── create-rule.md ✅
    ├── create-workflow.md ✅
    └── ...

### 次のステップ
1. `stack.md` を確認してプロジェクト固有の設定を調整
2. `/create-rule` で追加のルールを作成
3. `/create-workflow` でプロジェクト固有のワークフローを作成
```
```

`.agent/workflows/type-check.md`

**サイズ**: 549.0 B | **行数**: 20 行
```markdown
---
description: TypeScriptの型チェックを実行する原子ワークフロー。
---
# 型チェック (Type Check)

## 実行 // turbo
型チェックを実行せよ：
```bash
pnpm typecheck || npx tsc --noEmit || yarn tsc --noEmit
```

## 結果判定
- **成功**: 型エラーなし → `PASS` を返す
- **失敗**: 型エラーあり → `FAIL` を返す

## エラー時の出力
失敗した場合、以下を報告せよ：
- エラー数
- エラー箇所（ファイル名:行番号）
- エラー内容の要約（最大5件）
```

`.agent/workflows/ui-verification.md`

**サイズ**: 3.7 KB | **行数**: 114 行
```markdown
---
description: Browser Subagentを使用してUIの表示と機能を視覚的に検証する。
---
# UI検証 (UI Verification)

**ツール**: `browser_action`（Browser Subagent）を使用

このワークフローは、従来の単体テストでは捕捉できないUIの崩れや動的な挙動を視覚的に検証する。

---

## Step 1: 開発サーバー起動 // turbo
run_command を使用して開発サーバーを起動せよ：
```bash
pnpm dev || npm start || yarn dev
```

サーバーが起動するまで待機（通常3-5秒）。

## Step 2: ブラウザでアクセス
browser_action を使用してローカルサーバーにアクセスせよ：
- URL: http://localhost:3000（またはプロジェクト固有のポート）

ページが完全にロードされるまで待機。

## Step 3: 初期表示の検証
以下を確認せよ：
- ページが正常にレンダリングされているか
- 主要な要素（ヘッダー、ナビゲーション、フッター）が表示されているか
- コンソールにエラーが出力されていないか

スクリーンショットを撮影して保存：`screenshots/initial-load.png`

## Step 4: ユーザーインタラクションの実行
browser_action を使用して以下の操作を実行せよ：

### 4.1: ナビゲーションテスト
- 主要なリンクをクリック
- ページ遷移が正常に行われることを確認
- 404エラーが発生していないことを確認

### 4.2: フォームテスト（該当する場合）
- 入力フィールドにテストデータを入力
- 送信ボタンをクリック
- バリデーションメッセージが適切に表示されることを確認

### 4.3: モーダル/ダイアログテスト（該当する場合）
- トリガーボタン（例: "Sign Up"）をクリック
- モーダルが表示されることを確認
- 閉じるボタンでモーダルが閉じることを確認

各操作後にスクリーンショットを撮影。

## Step 5: レスポンシブ検証（オプション）
browser_action でビューポートサイズを変更し、レスポンシブデザインを検証せよ：

| デバイス | 幅 | 確認項目 |
|----------|-----|----------|
| Mobile | 375px | ハンバーガーメニューの表示 |
| Tablet | 768px | レイアウトの切り替え |
| Desktop | 1280px | フル表示 |

各サイズでスクリーンショットを撮影。

## Step 6: コンソールログの確認 // turbo
ブラウザのコンソールログを取得せよ：
- エラー（赤）
- 警告（黄）
- 情報（青）

エラーが検出された場合、内容を記録。

## Step 7: 結果判定

### Assert条件
以下のいずれかに該当する場合、タスクを「失敗」としてマーク：
- ページが表示されない（白画面、エラーページ）
- 主要な要素が欠落している
- コンソールにエラーが出力されている
- 404エラーが発生している
- モーダル/ダイアログが正常に動作しない

## Step 8: レポート生成
検証結果を以下の形式で報告せよ：

```
## UI検証レポート

**検証日時**: <timestamp>
**対象URL**: http://localhost:3000

### 結果サマリー
- 初期表示: ✅ OK / ❌ NG
- ナビゲーション: ✅ OK / ❌ NG
- フォーム: ✅ OK / ❌ NG / ➖ N/A
- モーダル: ✅ OK / ❌ NG / ➖ N/A
- レスポンシブ: ✅ OK / ❌ NG

### コンソールエラー
- エラー数: <N>
- 内容: <詳細>

### スクリーンショット
- screenshots/initial-load.png
- screenshots/navigation-test.png
- screenshots/modal-open.png
- ...

### 総合判定
✅ PASS / ❌ FAIL
```

## Step 9: クリーンアップ // turbo
開発サーバーを停止せよ（必要に応じて）。
```

`.agent/workflows/verify-code.md`

**サイズ**: 1.7 KB | **行数**: 56 行
```markdown
---
description: Lint、型チェック、テストを一括実行してコードの健全性を検証する合成ワークフロー。
---
# コード検証 (Verify Code)

**再帰的合成**: このワークフローは原子ワークフローを組み合わせて構成される。

```
/verify-code
├── /lint-check
├── /type-check
├── /run-tests
└── /security-scan (オプション)
```

---

## Step 1: Lintチェック
以下のワークフローを実行せよ：
- コマンド: `/lint-check`
- 失敗時: Step 5（結果集約）へスキップ

## Step 2: 型チェック
以下のワークフローを実行せよ：
- コマンド: `/type-check`
- 失敗時: Step 5（結果集約）へスキップ

## Step 3: テスト実行
以下のワークフローを実行せよ：
- コマンド: `/run-tests`
- 失敗時: Step 5（結果集約）へスキップ

## Step 4: セキュリティスキャン（オプション）
ユーザーが要求した場合、または重要な変更がある場合：
- コマンド: `/security-scan`
- 失敗時: Step 5（結果集約）へスキップ

## Step 5: 結果集約
各ワークフローの結果を集約して報告せよ：

```
## 検証結果サマリー

| チェック | 結果 | 詳細 |
|----------|------|------|
| Lint | ✅ PASS / ❌ FAIL | <詳細> |
| 型チェック | ✅ PASS / ❌ FAIL | <詳細> |
| テスト | ✅ PASS / ❌ FAIL | <詳細> |
| セキュリティ | ✅ PASS / ⚠️ WARN / ❌ FAIL | <詳細> |

**総合結果**: ✅ ALL PASS / ❌ FAILED (<N>件)
```

## 総合判定
- **ALL PASS**: すべて成功 → 次のステップへ進行可能
- **FAILED**: 1つ以上失敗 → 修正が必要
```

