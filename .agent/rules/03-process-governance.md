---
trigger: always_on
slug: process-governance
inheritance: core
scope: global
---
# プロセスガバナンスルール (Process Governance Rules)

開発プロセスにおける自動化の範囲、判断基準、およびユーザーへのエスカレーションに関するルール。

## 1. 自動化 vs 手動介入の判断基準

### ✅ 自動化すべき領域
- **合意済みのタスク実行**: 実装、テスト、デバッグ、セルフチェックのループ
- **決定論的なタスク**: Lint修正、定型コード生成など
- **情報の取得・整理**: 現状把握、ログ分析、ドキュメント生成

### 🛑 手動介入を求めるべき領域
以下の条件に当てはまる場合、速やかにユーザーの判断を仰ぐこと。
**必ず `@rules/84-conversation-style.md` の選択肢方式で確認を取る。**

1. **同一エラーが2回以上連続**: アプローチを変えても解決しない場合
2. **外部システム認証**: OAuth、CAPTCHA、APIキーの新規取得など
3. **環境依存の強い問題**: OS権限（Permission denied）、ネットワーク制限、ランタイム不足など
4. **非可逆的な操作**: 本番データの削除、大規模な構成変更、git push
5. **設計・方針の最終決定**: 要件定義、プランの確定（GOサイン）
6. **セキュリティ関連の判断**: APIキー扱い、本番DB操作

## 2. 役割分担の原則

- **ユーザー (Human)**: **「合意」と「承認」**。要件を決め、プランにGOサインを出し、最終成果を確認する。
- **エージェント (AI)**: **「実行」と「完遂」**。合意されたプランに基づき、自律的にPDCAを回して責任を持って形にする。

## 3. プラン先出し実行ルール (Plan-First Loop)

実装や修正を開始する前に、必ず以下のステップを踏むこと：

1. **プランの提示**: 具体的な変更内容、サイクル数、リスクをユーザーに提示する。
2. **GOサインの取得**: ユーザーから「OK」「進めて」などの合意を得る。**ここが最大のチェックポイントである。**
3. **自律実行モード**: 一度GOが出たら、そのプランの範囲内であれば目指す完成形まで自律的に進行する。

## 4. エスカレーションの手順

自動化の限界や、プランからの大幅な逸脱が発生したら、以下のフォーマットで報告すること：

1. **現状の報告**: 何を試して、どこで止まったか
2. **原因の特定**: なぜ自動で進められないか
3. **具体的な依頼**: ユーザーに何を支援してほしいか（認証、判断など）
4. **次のステップ**: 解決後にどう再開するか

## 5. 無限ループの禁止

- 同じエラーに対して、アプローチを変えずに **2回以上繰り返さない**こと。
- **1回目の失敗後、別アプローチを試みる。2回目の失敗時点で即座にユーザーに報告して判断を仰ぐ。**
- ユーザーへの報告は `@rules/84-conversation-style.md` の選択肢方式で行うこと。

## 6. 例外規定

- **リファクタリング・移行タスク**: 既存コードの移行やリファクタリングを行う際は、効率よりも **`@rules/36-refactoring-policy.md`** による「機能等価性の維持」を絶対優先とする。

## 7. システムツール・コマンドエラー時の特別規定 (Anti-Loop mechanism) 🚨

- **システムツール操作の誤魔化し禁止**: システム側から「変更が単純すぎる」などのツール呼び出しエラーが返された場合、**絶対に別の無意味なコマンド（`echo` 等）を並列実行して状態をごまかそうとしてはいけない**。
- **自己修復の暴走停止**: 何らかの処理で予期せぬエラーが起きた際、無理やり通そうとするアプローチ（ゴリ押し）は行わず、直ちに動作を止めてユーザーに正直に報告し、指示を仰ぐこと。
- **無意味なコマンドの禁止**: プロジェクトの実践的目的に直結しない、単なるシステム的な時間稼ぎや状態書き換えのためのコマンド実行は、重大なプロセスガバナンス違反とみなす。
