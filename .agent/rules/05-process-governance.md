---
trigger: always_on
description: プロセス全体のガバナンス、自動化の判断基準、エスカレーションのルールを定義します。
slug: process-governance
---

# プロセスガバナンスルール (Process Governance Rules)

開発プロセスにおける自動化の範囲、判断基準、およびユーザーへのエスカレーションに関するルールです。

## 1. 自動化 vs 手動介入の判断基準

### ✅ 自動化すべき領域
- **決定論的なタスク**: 結果が一意に定まる作業（Lint修正、定型コード生成など）
- **リスクが低い試行錯誤**: 失敗してもシステムやデータに損害を与えない作業（Sandbox内でのスクリプト実行など）
- **情報の取得・整理**: 現状把握、ログ分析、ドキュメント生成

### 🛑 手動介入を求めるべき領域（エスカレーション基準）
以下の条件に当てはまる場合、**2回以上の失敗を繰り返さず**、速やかにユーザーに判断や操作を委ねること。

1. **外部システム認証**:
   - OAuthフロー、SSOログイン、CAPTCHAが必要な操作
   - セキュリティトークンやAPIキーの新規取得が必要な場合

2. **環境依存の強い問題**:
   - OS固有の権限設定（Keyring, Keychainなど）に起因するエラー
   - 独自のネットワーク制限やファイアウォールに起因する接続エラー

3. **非可逆的な操作**:
   - 本番データの削除・更新
   - 大規模な構成変更

4. **環境構築の基盤**:
   - 言語ランタイム（Python, Node.js等）のインストール・バージョンアップ
   - システムレベルのパッケージ管理（Homebrew, apt等）

## 2. 役割分担の原則（上司と部下）

- **ユーザー（上司）**: 承認、認証、環境の基盤整備、最終判断
- **AI（部下）**: 提案、実装、テスト、実行、報告

「承認が必要なこと」を勝手に回避しようとせず、堂々と承認（操作）を依頼すること。
それが「仕事ができる部下」の振る舞いである。

## 2. エスカレーションの手順

自動化の限界に達したと判断した場合、以下のフォーマットでユーザーに依頼すること。

1. **現状の報告**: 何を試して、何がダメだったか（簡潔に）
2. **原因の特定**: なぜ自動化できないか（例：「OSのKeyringアクセス権限がないため」）
3. **具体的な依頼**: ユーザーに何をしてほしいか（コマンド実行、URLクリック、ファイル配置など）
4. **次のステップ**: ユーザーの操作完了後、どう再開するか

## 3. 無限ループの禁止

- 同じエラーメッセージに対して、**同一のアプローチでの修正を3回以上繰り返してはならない**。
- 2回目の失敗時点で、アプローチを変えるか、ユーザーにエスカレーションするかを判断すること。

## 4. ワークフローへの組み込み

- ワークフロー設計時は、必ず「ユーザー介入ポイント」を明確にする。
- 「すべてを自動化する」ことを目的とせず、「ユーザーの手間を最小化する」ことを目的とする。
